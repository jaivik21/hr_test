From efb1388c20fc7fd27f7237783b3587a5b75e3363 Mon Sep 17 00:00:00 2001
From: divya-sindhi <divya.sindhi@techifysolutions.com>
Date: Mon, 10 Nov 2025 16:26:35 +0530
Subject: [PATCH] Refactored Endpoints and added new functionalities

- Added Candidate functionality
- Feedback functionality
- Email sent Functionality
- Added logger file
- Video recording functionality
- Removed unnecessary columns
- Improve overall analysis
---
 backend/app/config_loader.py                  |   5 +-
 backend/app/main.py                           |  50 +
 backend/app/middleware/auth_middleware.py     |  24 +-
 backend/app/middleware/timing_middleware.py   |   2 -
 backend/app/models.py                         |  34 +-
 backend/app/routers/candidate_router.py       | 347 ++++++
 backend/app/routers/feedback_router.py        |  11 +
 backend/app/routers/interview_router.py       | 101 +-
 backend/app/routers/media_router.py           |  87 +-
 backend/app/routers/question_router.py        |   4 +-
 backend/app/routers/response_router.py        |  76 +-
 backend/app/routers/session_router.py         |  59 +-
 backend/app/schemas/candidate_schema.py       |  11 +
 backend/app/schemas/feedback_schema.py        |   1 +
 backend/app/schemas/interview_schema.py       |   9 +-
 backend/app/schemas/user_schema.py            |   6 -
 backend/app/services/feedback_service.py      |   1 -
 backend/app/services/llm_service.py           |  21 +-
 backend/app/services/question_service.py      |   8 +-
 backend/app/services/storage_service.py       | 280 ++++-
 backend/app/services/stt_service.py           |  21 +-
 backend/app/services/summarization_service.py |   5 +-
 backend/app/services/tts_service.py           |  18 +-
 backend/app/sockets/interview_socket.py       |  77 +-
 backend/app/utils/decorators.py               |  18 -
 backend/app/utils/file_utils.py               |   1 -
 backend/app/utils/interview_utils.py          |   5 +-
 backend/app/utils/logger.py                   | 100 +-
 backend/app/utils/user_auth.py                |   5 +-
 backend/config.yaml                           |  14 +-
 backend/create_tables.py                      |   4 +-
 backend/requirements.txt                      |   5 +-
 frontend/src/App.tsx                          |   8 +-
 .../src/components/AddCandidateDialog.tsx     | 550 ++++++++++
 .../src/components/CandidateAnalytics.tsx     |  89 +-
 frontend/src/components/CandidateStart.tsx    | 387 ++++++-
 frontend/src/components/Candidates.tsx        | 166 +++
 frontend/src/components/CreateInterview.tsx   | 160 ++-
 .../src/components/EditQuestionsModal.tsx     |  46 +-
 frontend/src/components/InterviewDetail.tsx   | 121 ++-
 frontend/src/components/InterviewSession.tsx  | 998 +++++++++++++++++-
 frontend/src/components/InterviewsList.tsx    |  76 +-
 frontend/src/utils/api.ts                     | 124 +++
 frontend/vite.config.ts                       |   4 +
 44 files changed, 3835 insertions(+), 304 deletions(-)
 delete mode 100644 backend/app/middleware/timing_middleware.py
 create mode 100644 backend/app/routers/candidate_router.py
 create mode 100644 backend/app/schemas/candidate_schema.py
 delete mode 100644 backend/app/services/feedback_service.py
 delete mode 100644 backend/app/utils/decorators.py
 delete mode 100644 backend/app/utils/file_utils.py
 create mode 100644 frontend/src/components/AddCandidateDialog.tsx
 create mode 100644 frontend/src/components/Candidates.tsx

diff --git a/backend/app/config_loader.py b/backend/app/config_loader.py
index 2205290..44a0919 100644
--- a/backend/app/config_loader.py
+++ b/backend/app/config_loader.py
@@ -2,6 +2,9 @@
 
 import os
 import yaml
+from utils.logger import get_logger
+
+logger = get_logger(__name__)
 
 def load_config(path: str = None) -> dict:
     if path is None:
@@ -15,5 +18,5 @@ def load_config(path: str = None) -> dict:
         expanded = os.path.expandvars(raw)
         return yaml.safe_load(expanded) or {}
     except FileNotFoundError:
-        print(f"Warning: Could not find config.yaml at {path}")
+        logger.warning(f"Could not find config.yaml at {path}")
         return {}
\ No newline at end of file
diff --git a/backend/app/main.py b/backend/app/main.py
index ff8c7df..033790b 100644
--- a/backend/app/main.py
+++ b/backend/app/main.py
@@ -16,12 +16,18 @@ from routers.session_router import router as session_router
 from routers.interviewer_router import router as interviewer_router
 from routers.user_router import router as user_router
 from routers.feedback_router import router as feedback_router
+from routers.media_router import router as media_router
 from middleware.auth_middleware import AuthMiddleware
 from dotenv import load_dotenv
 from contextlib import asynccontextmanager
+from pathlib import Path
 import uvicorn
+from config_loader import load_config
+from routers.candidate_router import router as candidate_router
+from utils.logger import get_logger
 
 load_dotenv()
+logger = get_logger(__name__)
 
 @asynccontextmanager
 async def lifespan(app: FastAPI):
@@ -42,7 +48,51 @@ app.include_router(session_router)
 app.include_router(interviewer_router)
 app.include_router(user_router)
 app.include_router(feedback_router)
+app.include_router(media_router)
+app.include_router(candidate_router)
 
+# Serve media files (images and videos)
+def _find_backend_directory() -> Path:
+    current_file = Path(__file__).resolve()
+    current_dir = current_file.parent
+    
+    for parent in [current_dir] + list(current_dir.parents):
+        config_file = parent / 'config.yaml'
+        if config_file.exists():
+            return parent
+    
+    if 'app' in current_dir.parts:
+        app_index = current_dir.parts.index('app')
+        backend_parts = current_dir.parts[:app_index]
+        return Path(*backend_parts) if backend_parts else current_dir.parent
+    
+    return current_dir.parent
+
+config = load_config()
+storage_type = config.get('storage', {}).get('storage_type', 'local')
+if storage_type == 'local':
+    storage_path = config.get('storage', {}).get('storage_path')
+    
+    if storage_path:
+        storage_path = Path(storage_path)
+        if storage_path.is_absolute():
+            storage_path = storage_path.resolve()
+        else:
+            backend_dir = _find_backend_directory()
+            storage_path = (backend_dir / storage_path).resolve()
+    else:
+        backend_dir = _find_backend_directory()
+        storage_path = (backend_dir / 'storage').resolve()
+    
+    storage_path.mkdir(parents=True, exist_ok=True)
+    (storage_path / 'images').mkdir(parents=True, exist_ok=True)
+    (storage_path / 'videos').mkdir(parents=True, exist_ok=True)
+    (storage_path / 'temp').mkdir(parents=True, exist_ok=True)
+    
+    storage_path_str = str(storage_path)
+    logger.info(f"Mounting static files from: {storage_path.resolve()}")
+    logger.info(f"Videos will be served from: {storage_path.resolve() / 'videos'}")
+    app.mount("/api/media/files", StaticFiles(directory=storage_path_str), name="media_files")
 
 @app.get("/")
 async def root():
diff --git a/backend/app/middleware/auth_middleware.py b/backend/app/middleware/auth_middleware.py
index 115bf06..208c4de 100644
--- a/backend/app/middleware/auth_middleware.py
+++ b/backend/app/middleware/auth_middleware.py
@@ -3,6 +3,9 @@ from starlette.middleware.base import BaseHTTPMiddleware
 from fastapi.responses import JSONResponse
 import os
 from functools import wraps
+from utils.logger import get_logger
+
+logger = get_logger(__name__)
 
 API_KEY = os.getenv("API_KEY")
 
@@ -19,15 +22,34 @@ PUBLIC_PATHS = {
     "/api/interview/start-interview",
     "/api/interview/end-interview",
     "/api/interview/submit-answer",
+    "/api/interview/get-current-question",
     "/api/feedback/candidate-feedback",
+    "/api/media/upload-candidate-image",
+    "/api/media/upload-candidate-video",
+    "/api/media/upload-chunk",
 }
 
+# Paths that should be public (for media file access)
+PUBLIC_PATH_PREFIXES = [
+    "/api/media/files"
+]
+
 class AuthMiddleware(BaseHTTPMiddleware):
     async def dispatch(self, request: Request, call_next):
+        # Normalize path to handle double slashes (replace all occurrences)
         path = request.url.path
+        while "//" in path:
+            path = path.replace("//", "/")
+
+        if request.method == "OPTIONS":
+            return await call_next(request)
 
         if path in PUBLIC_PATHS:
             return await call_next(request)
+        
+        for prefix in PUBLIC_PATH_PREFIXES:
+            if path.startswith(prefix):
+                return await call_next(request)
 
         client_key = (
             request.headers.get("API_KEY")
@@ -49,6 +71,6 @@ def safe_route(func):
         except HTTPException:
             raise  
         except Exception as e:
-            print(f"[ERROR] {func.__name__} failed: {e}")
+            logger.error(f"{func.__name__} failed: {e}", exc_info=True)
             raise HTTPException(status_code=500, detail=str(e))
     return wrapper
\ No newline at end of file
diff --git a/backend/app/middleware/timing_middleware.py b/backend/app/middleware/timing_middleware.py
deleted file mode 100644
index c9ed88e..0000000
--- a/backend/app/middleware/timing_middleware.py
+++ /dev/null
@@ -1,2 +0,0 @@
-# Request timing logs
-
diff --git a/backend/app/models.py b/backend/app/models.py
index a8e27fd..fad5878 100644
--- a/backend/app/models.py
+++ b/backend/app/models.py
@@ -63,7 +63,8 @@ class Interview(Base):
     created_at = Column(TIMESTAMP(timezone=True), server_default=func.now())
     name = Column(Text)
     description = Column(Text)
-    objective = Column(Text)
+    department = Column(Text)
+    job_description = Column(Text)
     organization_id = Column(UUID(as_uuid=True), ForeignKey("organization.id"))
     user_id = Column(UUID(as_uuid=True), ForeignKey("user.id"))
     interviewer_id = Column(UUID(as_uuid=True), ForeignKey("interviewer.id"))
@@ -72,9 +73,6 @@ class Interview(Base):
     is_open = Column(Boolean, default=True)
     url = Column(Text)
     readable_slug = Column(Text)
-    questions = Column(JSONB)
-    insights = Column(ARRAY(Text))
-    respondents = Column(ARRAY(Text))
     question_count = Column(Integer)
     response_count = Column(Integer)
     time_duration = Column(Text)
@@ -90,6 +88,22 @@ class Interview(Base):
     responses = relationship("Response", back_populates="interview", cascade="all, delete-orphan")
     feedbacks = relationship("Feedback", back_populates="interview", cascade="all, delete-orphan")
 
+class Candidate(Base):
+    __tablename__ = "candidate"
+
+    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
+    created_at = Column(TIMESTAMP(timezone=True), server_default=func.now())
+    interview_id = Column(UUID(as_uuid=True), ForeignKey("interview.id"), nullable=False)
+    name = Column(Text, nullable=False)
+    email = Column(Text, nullable=False)
+    phone_number = Column(Text)
+    mail_sent = Column(Boolean, default=False)
+    response_id = Column(UUID(as_uuid=True), ForeignKey("response.id"), nullable=True)
+
+    interview = relationship("Interview")
+    response = relationship("Response")
+ 
+
 class Response(Base):
     __tablename__ = "response"
 
@@ -105,12 +119,14 @@ class Response(Base):
     is_completed = Column(Boolean, default=False)
     qa_history = Column(JSONB, default=[])  
     duration = Column(Integer)  
-    video_chunks_count = Column(Integer, default=0)
-    question_audio_count = Column(Integer, default=0)
     status = Column(String, default="no_status")
-    status_source = Column(String, default="auto")
+    status_source = Column(String, default="manual")
+    candidate_image_url = Column(Text, nullable=True)
+    candidate_video_url = Column(Text, nullable=True)
+    overall_analysis = Column(JSONB, default={})
 
     interview = relationship("Interview", back_populates="responses")
+    feedbacks = relationship("Feedback", back_populates="response", cascade="all, delete-orphan")
 
 class Feedback(Base):
     __tablename__ = "feedback"
@@ -118,8 +134,10 @@ class Feedback(Base):
     id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
     created_at = Column(TIMESTAMP(timezone=True), server_default=func.now())
     interview_id = Column(UUID(as_uuid=True), ForeignKey("interview.id"))
+    response_id = Column(UUID(as_uuid=True), ForeignKey("response.id"))
     email = Column(Text)
     feedback = Column(Text)
     satisfaction = Column(Integer)
     
-    interview = relationship("Interview", back_populates="feedbacks")
\ No newline at end of file
+    interview = relationship("Interview", back_populates="feedbacks")
+    response = relationship("Response", back_populates="feedbacks")
\ No newline at end of file
diff --git a/backend/app/routers/candidate_router.py b/backend/app/routers/candidate_router.py
new file mode 100644
index 0000000..b237951
--- /dev/null
+++ b/backend/app/routers/candidate_router.py
@@ -0,0 +1,347 @@
+from fastapi import APIRouter, HTTPException, UploadFile, File, Form, Query, Body
+from typing import Optional, List, Dict, Any
+import csv
+import io
+import os
+from sqlalchemy import select
+from db import AsyncSessionLocal
+from models import Candidate, Interview, Response
+import pandas as pd
+from schemas.candidate_schema import CreateCandidateRequest
+from middleware.auth_middleware import safe_route
+from utils.interview_utils import get_interview_or_404
+from utils.user_auth import send_email
+from utils.logger import get_logger
+
+logger = get_logger(__name__)
+router = APIRouter(prefix="/api/interview", tags=["candidates"])
+
+
+def _serialize_candidate(c: Candidate) -> dict:
+    return {
+        "id": str(c.id),
+        "interview_id": str(c.interview_id),
+        "name": c.name,
+        "email": c.email,
+        "phone_number": c.phone_number,
+        "mail_sent": getattr(c, 'mail_sent', False),
+        "created_at": c.created_at.isoformat() if getattr(c, "created_at", None) else None,
+    }
+
+
+async def _attach_response_if_exists(db, candidate: Candidate):
+    if candidate.response_id:
+        return
+    result = await db.execute(
+        select(Response)
+        .where(Response.interview_id == candidate.interview_id)
+        .where(Response.email == candidate.email)
+    )
+    resp = result.scalar_one_or_none()
+    if resp:
+        candidate.response_id = resp.id
+
+
+def _get_interview_link(interview: Interview) -> str:
+    frontend_base_url = os.getenv("FRONTEND_BASE_URL", "http://localhost:5173")
+    if interview.readable_slug:
+        return f"{frontend_base_url}/candidate/interview/{interview.readable_slug}"
+    elif interview.url:
+        return f"{frontend_base_url}{interview.url}"
+    return f"{frontend_base_url}/candidate/interview/{interview.id}"
+
+async def _send_invite_to_candidate(db, candidate: Candidate, interview: Interview) -> bool:
+    try:
+        candidate_link = _get_interview_link(interview)
+        subject = f"Interview Invitation: {interview.name}"
+        body = f"""Hello {candidate.name},
+
+        You have been invited to take an interview for: {interview.name}
+
+        Please click the link below to start your interview:
+        {candidate_link}
+
+        Best regards,
+        The Interview Team"""
+        
+        send_email(candidate.email, subject, body)
+        candidate.mail_sent = True
+        return True
+    except Exception as e:
+        logger.error(f"Failed to send invite to candidate {candidate.email}: {e}", exc_info=True)
+        return False
+
+
+async def _check_duplicate_candidate(db, interview_id: str, email: str) -> bool:
+    result = await db.execute(
+        select(Candidate)
+        .where(Candidate.interview_id == interview_id)
+        .where(Candidate.email == email)
+    )
+    return result.scalar_one_or_none() is not None
+
+async def _create_candidate(db, interview_id: str, name: str, email: str, phone_number: Optional[str] = None) -> Candidate:
+    candidate = Candidate(
+        interview_id=interview_id,
+        name=name,
+        email=email,
+        phone_number=phone_number,
+        mail_sent=False,
+    )
+    await _attach_response_if_exists(db, candidate)
+    db.add(candidate)
+    return candidate
+
+@router.post("/add-candidate")
+@safe_route
+async def add_candidate(payload: CreateCandidateRequest):
+    async with AsyncSessionLocal() as db:
+        interview = await get_interview_or_404(db, str(payload.interview_id))
+        
+        if await _check_duplicate_candidate(db, str(payload.interview_id), payload.email):
+            raise HTTPException(status_code=409, detail="Candidate with this email already exists for the interview")
+
+        candidate = await _create_candidate(db, str(payload.interview_id), payload.name, payload.email, payload.phone_number)
+        await db.commit()
+        await db.refresh(candidate)
+        
+        return {"ok": True, "candidate": _serialize_candidate(candidate)}
+
+
+def _normalize_header(header: str) -> str:
+    header = header.strip().lower()
+    if header in ["phone number", "phone", "phone_number", "phonenumber"]:
+        return "phone_number"
+    return header
+
+def _parse_upload_file(content: bytes, file_extension: str) -> List[Dict[str, Any]]:
+    if file_extension == ".xlsx":
+        try:
+            df = pd.read_excel(io.BytesIO(content))
+            df.columns = df.columns.str.strip()
+            rows = df.to_dict("records")
+        except ImportError:
+            raise HTTPException(
+                status_code=400, 
+                detail="XLSX support requires pandas library. Please install it or use CSV format."
+            )
+        except Exception as e:
+            raise HTTPException(status_code=400, detail=f"Failed to parse XLSX file: {str(e)}")
+    else:
+        try:
+            text = content.decode("utf-8-sig", errors="replace")
+        except Exception:
+            raise HTTPException(status_code=400, detail="CSV must be UTF-8 encoded")
+        reader = csv.DictReader(io.StringIO(text, newline=""))
+        rows = list(reader)
+    
+    if not rows:
+        raise HTTPException(status_code=400, detail="File is empty or has no data rows")
+    
+    original_headers = list(rows[0].keys()) if rows else []
+    
+    normalized_rows = []
+    for row in rows:
+        normalized_row = {_normalize_header(k): v for k, v in row.items()}
+        normalized_rows.append(normalized_row)
+    
+    required = {"name", "email"}
+    if not required.issubset(set(normalized_rows[0].keys())):
+        raise HTTPException(
+            status_code=400, 
+            detail=f"File must include headers: Name/name, Email/email[, Phone Number/phone_number]. Found headers: {', '.join(original_headers)}"
+        )
+    
+    return normalized_rows
+
+@router.post("/bulk-upload")
+@safe_route
+async def bulk_upload_candidates(
+    interview_id: str = Form(...),
+    file: UploadFile = File(...),
+):
+    async with AsyncSessionLocal() as db:
+        interview = await get_interview_or_404(db, interview_id)
+
+        content = await file.read()
+        file_extension = os.path.splitext(file.filename or "")[1].lower()
+        
+        if file_extension not in [".csv", ".xlsx"]:
+            raise HTTPException(
+                status_code=400,
+                detail="Unsupported file format. Please upload a .csv or .xlsx file."
+            )
+        
+        rows = _parse_upload_file(content, file_extension)
+        created: List[Candidate] = []
+        skipped: List[dict] = []
+        
+        for row in rows:
+            name = (row.get("name") or "").strip()
+            email = (row.get("email") or "").strip()
+            phone = (row.get("phone_number") or "").strip() or None
+            
+            if not name or not email:
+                skipped.append({"email": email, "reason": "missing name/email"})
+                continue
+
+            if await _check_duplicate_candidate(db, interview_id, email):
+                skipped.append({"email": email, "reason": "duplicate"})
+                continue
+
+            candidate = await _create_candidate(db, interview_id, name, email, phone)
+            created.append(candidate)
+
+        await db.commit()
+        for c in created:
+            await db.refresh(c)
+        
+        return {
+            "ok": True,
+            "created": [_serialize_candidate(c) for c in created],
+            "skipped": skipped,
+        }
+
+
+@router.get("/list-candidates")
+@safe_route
+async def list_candidates(interview_id: str = Query(...)):
+    async with AsyncSessionLocal() as db:
+        await get_interview_or_404(db, interview_id)
+        result = await db.execute(
+            select(Candidate).where(Candidate.interview_id == interview_id)
+        )
+        candidates = result.scalars().all()
+
+        changed = False
+        for c in candidates:
+            if not c.response_id:
+                await _attach_response_if_exists(db, c)
+                if c.response_id:
+                    changed = True
+        
+        if changed:
+            await db.commit()
+
+        return {"ok": True, "candidates": [_serialize_candidate(c) for c in candidates]}
+
+
+async def _get_candidate_by_id_or_email(db, interview_id: str, candidate_id: Optional[str] = None, email: Optional[str] = None) -> Optional[Candidate]:
+    if candidate_id:
+        result = await db.execute(
+            select(Candidate)
+            .where(Candidate.id == candidate_id)
+            .where(Candidate.interview_id == interview_id)
+        )
+    elif email:
+        result = await db.execute(
+            select(Candidate)
+            .where(Candidate.interview_id == interview_id)
+            .where(Candidate.email == email.lower().strip())
+        )
+    else:
+        return None
+    
+    return result.scalar_one_or_none()
+
+@router.post("/send-invite")
+@safe_route
+async def send_invite(
+    interview_id: str = Body(...),
+    candidate_id: Optional[str] = Body(None),
+    email: Optional[str] = Body(None),
+):
+    """
+    Send invites to candidates.
+    
+    Single candidate:
+    - candidate_id: Send to one candidate by ID
+    - email: Send to one candidate by email
+    
+    Send to all (when neither candidate_id nor email provided):
+    - Automatically sends to all candidates who haven't received invites yet
+    - Skips candidates who already have mail_sent=True
+    """
+    async with AsyncSessionLocal() as db:
+        interview = await get_interview_or_404(db, interview_id)
+        
+        if candidate_id or email:
+            candidate = await _get_candidate_by_id_or_email(db, interview_id, candidate_id, email)
+            if not candidate:
+                raise HTTPException(
+                    status_code=404,
+                    detail="Candidate not found. Please add the candidate first."
+                )
+            
+            if candidate.mail_sent:
+                return {
+                    "ok": True,
+                    "invite_sent": False,
+                    "message": "Invite already sent to this candidate",
+                    "candidate": _serialize_candidate(candidate)
+                }
+            
+            invite_sent = await _send_invite_to_candidate(db, candidate, interview)
+            await db.commit()
+            await db.refresh(candidate)
+            
+            return {
+                "ok": True,
+                "invite_sent": invite_sent,
+                "candidate": _serialize_candidate(candidate)
+            }
+        
+        query = select(Candidate).where(
+            Candidate.interview_id == interview_id,
+            Candidate.mail_sent == False
+        )
+        result = await db.execute(query)
+        candidates = result.scalars().all()
+        
+        if not candidates:
+            return {
+                "ok": True,
+                "message": "No candidates found to send invites to (all have already received invites)",
+                "sent": 0,
+                "failed": 0,
+                "total": 0,
+                "results": []
+            }
+        
+        results = []
+        sent_count = 0
+        failed_count = 0
+        
+        for candidate in candidates:
+            invite_sent = await _send_invite_to_candidate(db, candidate, interview)
+            if invite_sent:
+                sent_count += 1
+                results.append({
+                    "candidate_id": str(candidate.id),
+                    "email": candidate.email,
+                    "name": candidate.name,
+                    "status": "sent"
+                })
+            else:
+                failed_count += 1
+                results.append({
+                    "candidate_id": str(candidate.id),
+                    "email": candidate.email,
+                    "name": candidate.name,
+                    "status": "failed"
+                })
+        
+        await db.commit()
+        
+        logger.info(f"Bulk invite sent: {sent_count} successful, {failed_count} failed for interview {interview_id}")
+        
+        return {
+            "ok": True,
+            "sent": sent_count,
+            "failed": failed_count,
+            "total": len(candidates),
+            "results": results
+        }
+
+
+ 
\ No newline at end of file
diff --git a/backend/app/routers/feedback_router.py b/backend/app/routers/feedback_router.py
index b3cf603..cbdf5db 100644
--- a/backend/app/routers/feedback_router.py
+++ b/backend/app/routers/feedback_router.py
@@ -6,6 +6,7 @@ from sqlalchemy import select
 from models import Feedback, Interview
 from schemas.feedback_schema import CreateFeedbackRequest
 from utils.interview_utils import commit_and_refresh
+from sqlalchemy import desc
 
 
 router = APIRouter(prefix="/api/feedback", tags=["feedback"])
@@ -21,6 +22,7 @@ async def create_feedback(payload: CreateFeedbackRequest):
 
         fb = Feedback(
             interview_id=payload.interview_id,
+            response_id=payload.response_id,
             email=payload.email,
             feedback=payload.feedback,
             satisfaction=payload.satisfaction,
@@ -28,3 +30,12 @@ async def create_feedback(payload: CreateFeedbackRequest):
         db.add(fb)
         await commit_and_refresh(db, fb)
         return {"status": "ok", "feedback_id": str(fb.id), "message": "Feedback submitted successfully"}
+
+
+
+@router.get("/list-feedbacks")
+async def list_feedbacks():
+    async with AsyncSessionLocal() as db:
+        result = await db.execute(select(Feedback).order_by(desc(Feedback.created_at)))
+        feedbacks = result.scalars().all()
+        return {"status": "ok", "feedbacks": feedbacks}
\ No newline at end of file
diff --git a/backend/app/routers/interview_router.py b/backend/app/routers/interview_router.py
index 5597645..0591a76 100644
--- a/backend/app/routers/interview_router.py
+++ b/backend/app/routers/interview_router.py
@@ -5,7 +5,7 @@ import uuid
 from sqlalchemy import select, func, desc
 from sqlalchemy.orm.attributes import flag_modified
 from db import AsyncSessionLocal
-from models import Interview, Response
+from models import Interview, Response, Candidate, Interviewer
 from schemas.interview_schema import (
     DeleteInterviewRequest,
     ToggleInterviewStatusRequest,
@@ -23,7 +23,7 @@ from middleware.auth_middleware import safe_route
 
 router = APIRouter(prefix="/api/interview", tags=["interview"])
 
-def serialize_interview(interview, responses_count: Optional[int] = None, include_created_at: bool = False):
+def serialize_interview(interview, responses_count: Optional[int] = None, include_created_at: bool = False, stats: Optional[dict] = None):
     questions = get_questions_list(interview)
     candidate_link = None
     if interview.readable_slug:
@@ -36,7 +36,8 @@ def serialize_interview(interview, responses_count: Optional[int] = None, includ
     result = {
         "id": str(interview.id),
         "name": interview.name,
-        "objective": interview.objective,
+        "job_description": getattr(interview, 'job_description', None),
+        "department": getattr(interview, 'department', None),
         "mode": interview.question_mode,
         "question_count": interview.question_count,
         "context": interview.context,
@@ -54,13 +55,17 @@ def serialize_interview(interview, responses_count: Optional[int] = None, includ
     if include_created_at:
         result["created_at"] = interview.created_at.isoformat() if interview.created_at else None
     
+    if stats:
+        result["stats"] = stats
+    
     return result
 
 @router.post("/create-interview")
 @safe_route
 async def create_interview(
     name: str = Form(...),
-    objective: str = Form(...),
+    job_description: str = Form(...),
+    department: Optional[str] = Form(None),
     mode: str = Form(...),
     question_count: int = Form(...),
     auto_question_generate: bool = Form(...),
@@ -103,14 +108,14 @@ async def create_interview(
         
         interview = Interview(
             name=name,
-            objective=objective,
+            job_description=job_description,
+            department=department,
             question_mode=mode,
             question_count=question_count,
             auto_question_generate=auto_question_generate,
             manual_questions=parse_manual_questions(manual_questions),
             interviewer_id=interviewer_id_uuid,
             time_duration=time_duration_str,
-            respondents=None,
             url=url,
             readable_slug=readable_slug
         )
@@ -121,9 +126,9 @@ async def create_interview(
             interview.context = {}
         interview.context["difficulty_level"] = difficulty_level
         if "context_summary" not in interview.context:
-            interview.context["context_summary"] = f"Interview objective: {objective}"
-        flag_modified(interview, 'context')  
-        
+            interview.context["context_summary"] = f"Interview job_description: {job_description}"
+        flag_modified(interview, 'context')
+
         if jd_file:
             allowed_extensions = ['.pdf', '.docx', '.doc', '.txt']
             file_extension = Path(jd_file.filename).suffix.lower()
@@ -160,7 +165,41 @@ async def list_interviews():
                 if (r.qa_history and len(r.qa_history) > 0) or getattr(r, 'overall_analysis', None) is not None
             )
             
-            items.append(serialize_interview(it, responses_count=actual_response_count, include_created_at=True))
+            sent_result = await db.execute(
+                select(func.count(Candidate.id))
+                .where(Candidate.interview_id == it.id)
+                .where(Candidate.mail_sent == True)
+            )
+            sent_count = sent_result.scalar() or 0
+            
+            shortlisted_result = await db.execute(
+                select(func.count(Response.id))
+                .where(Response.interview_id == it.id)
+                .where(Response.status == "shortlisted")
+            )
+            shortlisted_count = shortlisted_result.scalar() or 0
+            
+            candidates_sent_result = await db.execute(
+                select(Candidate)
+                .where(Candidate.interview_id == it.id)
+                .where(Candidate.mail_sent == True)
+            )
+            candidates_sent_list = candidates_sent_result.scalars().all()
+            completed_response_ids = {r.id for r in completed_responses}
+            
+            pending_count = sum(
+                1 for c in candidates_sent_list
+                if not c.response_id or c.response_id not in completed_response_ids
+            )
+            
+            stats = {
+                "sent": sent_count,
+                "given": actual_response_count,
+                "shortlisted": shortlisted_count,
+                "pending": pending_count
+            }
+            
+            items.append(serialize_interview(it, responses_count=actual_response_count, include_created_at=True, stats=stats))
         return {"ok": True, "interviews": items}
 
 
@@ -171,10 +210,14 @@ async def update_interview(
     mode: Optional[str] = Form(None),
     auto_question_generate: Optional[bool] = Form(None),
     manual_questions: Optional[str] = Form(None),
-    objective: Optional[str] = Form(None),
+    job_description: Optional[str] = Form(None),
+    department: Optional[str] = Form(None),
     description: Optional[str] = Form(None),
     name: Optional[str] = Form(None),
     difficulty_level: Optional[str] = Form(None),
+    question_count: Optional[int] = Form(None),
+    interviewer_id: Optional[str] = Form(None),
+    duration_minutes: Optional[int] = Form(None),
 ):
     async with AsyncSessionLocal() as db:
         interview = await get_interview_or_404(db, interview_id)
@@ -182,11 +225,37 @@ async def update_interview(
         original_mode = interview.question_mode
         original_qc = interview.question_count
 
-        name = name or interview.name
-        objective = objective or interview.objective
-        description = description or interview.description
-        mode = mode or interview.question_mode
-        auto_question_generate = auto_question_generate or interview.auto_question_generate
+        if name is not None:
+            interview.name = name
+        if job_description is not None:
+            interview.job_description = job_description
+        if department is not None:
+            interview.department = department
+        if description is not None:
+            interview.description = description
+        if mode is not None:
+            interview.question_mode = mode
+        mode = interview.question_mode  
+        auto_question_generate = auto_question_generate if auto_question_generate is not None else interview.auto_question_generate
+        if question_count is not None and question_count > 0:
+            interview.question_count = question_count
+        
+        if interviewer_id is not None:
+            if interviewer_id == "":
+                interview.interviewer_id = None
+            else:
+                try:
+                    interviewer_id_uuid = uuid.UUID(interviewer_id)
+                    interviewer_check = await db.execute(
+                        select(Interviewer).where(Interviewer.id == interviewer_id_uuid)
+                    )
+                    if interviewer_check.scalar_one_or_none():
+                        interview.interviewer_id = interviewer_id_uuid
+                except ValueError:
+                    raise HTTPException(status_code=400, detail="Invalid interviewer_id format")
+        
+        if duration_minutes is not None and duration_minutes > 0:
+            interview.time_duration = str(duration_minutes)
         
         if manual_questions is not None:
             parsed_questions = parse_manual_questions(manual_questions)
diff --git a/backend/app/routers/media_router.py b/backend/app/routers/media_router.py
index 82ba319..22f5fc8 100644
--- a/backend/app/routers/media_router.py
+++ b/backend/app/routers/media_router.py
@@ -1,36 +1,67 @@
-from fastapi import APIRouter, UploadFile, File, HTTPException
-from typing import Dict
+from fastapi import APIRouter, UploadFile, File, Form, BackgroundTasks, Request
 from services.storage_service import storage_service
+from db import AsyncSessionLocal
+from utils.interview_utils import get_response_or_404
+from utils.logger import get_logger
+import asyncio      
 
-
+logger = get_logger(__name__)
 router = APIRouter(prefix="/api/media", tags=["media"])
 
 
 @router.post("/upload-candidate-image")
-async def upload_candidate_image(file: UploadFile = File(...)) -> Dict[str, str]:
-    try:
-        data = await file.read()
-        saved_path = storage_service.save_image(file.filename or "image.png", data)
-        return {
-            "status": "ok",
-            "path": str(saved_path),
-            "filename": saved_path.name,
-        }
-    except Exception as e:
-        raise HTTPException(status_code=500, detail="Failed to save image") from e
-
-
-@router.post("/upload-screen-recording")
-async def upload_screen_recording(file: UploadFile = File(...)) -> Dict[str, str]:
-    try:
-        data = await file.read()
-        saved_path = storage_service.save_video(file.filename or "recording.webm", data)
-        return {
-            "status": "ok",
-            "path": str(saved_path),
-            "filename": saved_path.name,
-        }
-    except Exception as e:
-        raise HTTPException(status_code=500, detail="Failed to save video") from e
+async def upload_candidate_image(image: UploadFile = File(...), response_id: str = Form(...)):
+    async with AsyncSessionLocal() as db:
+        response = await get_response_or_404(db, response_id)
+        content = await image.read()
+        file_extension = image.filename.split('.')[-1].lower()
+
+        storage_url = await storage_service.save_candidate_image(content, response_id, file_extension)
+
+        response.candidate_image_url = storage_url
+        await db.commit()
+        await db.refresh(response)
+        return {"ok": True, "storage_path": storage_url}
+
+
+async def _merge_video_background(response_id: str, base_url: str = None):
+    logger.info(f"Starting video merge for response_id: {response_id}")
+    await asyncio.sleep(3)  
+
+    retries = 3
+    for attempt in range(retries):
+        try:
+            logger.info(f"Attempt {attempt + 1}/{retries} for response_id: {response_id}")
+            merged_path = await storage_service.save_candidate_video(response_id, base_url)
+            if merged_path:
+                async with AsyncSessionLocal() as db:
+                    response = await get_response_or_404(db, response_id)
+                    if hasattr(response, 'candidate_video_url') and response.candidate_video_url != merged_path:
+                        response.candidate_video_url = merged_path
+                        await db.commit()
+                logger.info(f"Successfully merged video for response_id: {response_id}, path: {merged_path}")
+                return
+            else:
+                logger.warning(f"No merged path returned for response_id: {response_id}")
+        except Exception as e:
+            logger.error(f"Attempt {attempt + 1} failed for response_id {response_id}: {e}", exc_info=True)
+            if attempt < retries - 1:
+                await asyncio.sleep(2)
+    
+    logger.error(f"Failed to merge video after {retries} attempts for response_id: {response_id}")
+
+def _video_already_exists(response_id: str) -> bool:
+    video_path = storage_service.video_dir / f"{response_id}.mp4"
+    return video_path.exists() and video_path.stat().st_size > 0
+
+@router.post("/upload-candidate-video")
+async def upload_candidate_video(request: Request, response_id: str = Form(...), background_tasks: BackgroundTasks = BackgroundTasks()):
+    async with AsyncSessionLocal() as db:
+        response = await get_response_or_404(db, response_id)
+        if response.candidate_video_url and _video_already_exists(response_id):
+            return {"ok": True, "message": "Video already exists, skipping merge"}
+
+    background_tasks.add_task(_merge_video_background, response_id, str(request.base_url))
+    return {"ok": True, "message": "Video merge started in background"}
 
 
diff --git a/backend/app/routers/question_router.py b/backend/app/routers/question_router.py
index 9cce857..cd0bd91 100644
--- a/backend/app/routers/question_router.py
+++ b/backend/app/routers/question_router.py
@@ -7,7 +7,9 @@ from schemas.interview_schema import GenerateQuestionsRequest
 from services.question_service import QuestionService
 from utils.interview_utils import get_interview_or_404, get_response_or_404, get_questions_list, question_text, synthesize_tts
 from middleware.auth_middleware import safe_route
+from utils.logger import get_logger
 
+logger = get_logger(__name__)
 router = APIRouter(prefix="/api/interview", tags=["questions"])
 
 
@@ -40,7 +42,7 @@ async def _add_tts_to_result(result: dict, q_text: str, voice_id: Optional[str])
             if tts_data:
                 result.update(tts_data)
         except Exception as e:
-            print(f"[ERROR] TTS synthesis failed: {e}")
+            logger.error(f"TTS synthesis failed: {e}", exc_info=True)
 
 
 @router.post("/generate-questions")
diff --git a/backend/app/routers/response_router.py b/backend/app/routers/response_router.py
index c8afb85..a2e1d36 100644
--- a/backend/app/routers/response_router.py
+++ b/backend/app/routers/response_router.py
@@ -1,4 +1,4 @@
-from fastapi import APIRouter, HTTPException, Query, Depends
+from fastapi import APIRouter, HTTPException, Query, Depends, BackgroundTasks
 from datetime import datetime, timezone
 from sqlalchemy import select
 from sqlalchemy.orm.attributes import flag_modified
@@ -16,29 +16,31 @@ from utils.interview_utils import (
     question_text,
     format_duration
 )
+from utils.logger import get_logger
 
+logger = get_logger(__name__)
 router = APIRouter(prefix="/api/interview", tags=["responses"])
 
-def _auto_assign_status(score: int) -> str:
-    if score >= 80:
-        return "selected"
-    elif score >= 60:
-        return "potential"
-    elif score < 40:
-        return "not_selected"
-    else:
-        return "potential"
+# def _auto_assign_status(score: int) -> str:
+#     if score >= 80:
+#         return "selected"
+#     elif score >= 60:
+#         return "potential"
+#     elif score < 40:
+#         return "not_selected"
+#     else:
+#         return "potential"
 
-async def _assign_status_if_needed(db, response, overall_analysis: dict):
-    if not overall_analysis:
-        return
+# async def _assign_status_if_needed(db, response, overall_analysis: dict):
+#     if not overall_analysis:
+#         return
     
-    status = getattr(response, 'status', None) or "no_status"
-    if status == "no_status":
-        score = overall_analysis.get("overall_score", 0)
-        response.status = _auto_assign_status(score)
-        response.status_source = "auto"
-        await db.commit()
+#     status = getattr(response, 'status', None) or "no_status"
+#     if status == "no_status":
+#         score = overall_analysis.get("overall_score", 0)
+#         response.status = _auto_assign_status(score)
+#         response.status_source = "auto"
+#         await db.commit()
 
 async def _ensure_analysis(db, response, interview_id: str) -> dict:
     overall_analysis = getattr(response, "overall_analysis", None)
@@ -115,7 +117,7 @@ def _build_transcript(qa_history: list, candidate_name: str) -> list:
     return transcript
 
 @router.post("/submit-answer")
-async def submit_answer(request: SubmitAnswerRequest):
+async def submit_answer(request: SubmitAnswerRequest, background_tasks: BackgroundTasks = BackgroundTasks()):
     async with AsyncSessionLocal() as db:
         response = await get_response_or_404(db, request.response_id)
         interview = await get_interview_or_404(db, str(response.interview_id))
@@ -167,7 +169,7 @@ async def submit_answer(request: SubmitAnswerRequest):
                         str(interview.id), response.qa_history
                     )
                     setattr(response, "overall_analysis", final_analysis)
-                    await _assign_status_if_needed(db, response, final_analysis)
+                    # await _assign_status_if_needed(db, response, final_analysis)
                 except Exception:
                     pass
         
@@ -177,6 +179,11 @@ async def submit_answer(request: SubmitAnswerRequest):
         except Exception as e:
             await db.rollback()
             raise HTTPException(status_code=500, detail=f"Failed to save response: {str(e)}")
+        
+        if is_complete:
+            from routers.media_router import _merge_video_background
+            background_tasks.add_task(_merge_video_background, str(response.id), None)
+            logger.debug(f"Video merge task added for auto-completed interview, response_id: {response.id}")
 
         return {
             "ok": True,
@@ -215,9 +222,9 @@ async def get_overall_analysis(interview_id: str = Query(...)):
             communication_score = overall_analysis.get("communication_score", 0)
             
             status = getattr(r, 'status', None) or "no_status"
-            if overall_analysis and status == "no_status":
-                await _assign_status_if_needed(db, r, overall_analysis)
-                status = r.status
+            # if overall_analysis and status == "no_status":
+            #     await _assign_status_if_needed(db, r, overall_analysis)
+            #     status = r.status
             
             candidates.append({
                 "response_id": str(r.id),
@@ -228,7 +235,9 @@ async def get_overall_analysis(interview_id: str = Query(...)):
                 "summary": _get_candidate_summary(overall_analysis),
                 "status": status,
                 "status_source": r.status_source if hasattr(r, 'status_source') else "auto",
-                "created_at": r.created_at.isoformat() if r.created_at else None
+                "created_at": r.created_at.isoformat() if r.created_at else None,
+                "image_url": getattr(r, 'candidate_image_url', None),
+                "video_url": getattr(r, 'candidate_video_url', None)
             })
             
             if r.duration:
@@ -248,7 +257,8 @@ async def get_overall_analysis(interview_id: str = Query(...)):
             "interview": {
                 "id": str(interview.id),
                 "name": interview.name,
-                "objective": interview.objective or "",
+                "job_description": getattr(interview, "job_description", None) or "",
+                "department": getattr(interview, "department", None) or "",
                 "description": getattr(interview, "description", None) or "",
                 "time_duration": interview.time_duration  
             },
@@ -273,7 +283,7 @@ async def get_response_detail(response_id: str = Query(...)):
         interview = await get_interview_or_404(db, str(response.interview_id))
         
         qa_history = response.qa_history or []
-        overall_analysis = await _ensure_analysis(db, response, str(interview.id))
+        overall_analysis = response.overall_analysis or {}
         
         duration_seconds, duration_formatted = _calculate_duration(response)
         question_summary = _build_question_summaries(interview, qa_history, overall_analysis)
@@ -284,27 +294,29 @@ async def get_response_detail(response_id: str = Query(...)):
             "interview": {
                 "id": str(interview.id),
                 "name": interview.name,
-                "objective": interview.objective or "",
+                "job_description": getattr(interview, "job_description", None) or "",
+                "department": getattr(interview, "department", None) or "",
                 "time_duration": interview.time_duration
             },
             "candidate": {
                 "response_id": str(response.id),
                 "name": response.name,
                 "email": response.email,
-                "created_at": response.created_at.isoformat() if response.created_at else None
+                "created_at": response.created_at.isoformat() if response.created_at else None,
+                "image_url": getattr(response, 'candidate_image_url', None)
             },
             "recording": {
                 "duration": duration_formatted,
                 "duration_seconds": duration_seconds,
-                "available": duration_seconds > 0
+                "available": duration_seconds > 0,
+                "video_url": getattr(response, 'candidate_video_url', None)
             },
             "general_summary": {
                 "overall_score": overall_analysis.get("overall_score", 0),
                 "overall_feedback": overall_analysis.get("overall_feedback", "") or overall_analysis.get("overallFeedback", ""),
                 "communication_score": overall_analysis.get("communication_score", 0),
                 "communication_feedback": overall_analysis.get("communication_feedback", ""),
-                "sentiment": overall_analysis.get("sentiment", "neutral").lower(),
-                "call_summary": ""
+                "sentiment": overall_analysis.get("sentiment", "neutral").lower()
             },
             "question_summary": question_summary,
             "transcript": transcript,
diff --git a/backend/app/routers/session_router.py b/backend/app/routers/session_router.py
index 54f535a..eb538e4 100644
--- a/backend/app/routers/session_router.py
+++ b/backend/app/routers/session_router.py
@@ -1,7 +1,8 @@
-from fastapi import APIRouter, HTTPException, Depends
+from fastapi import APIRouter, HTTPException, Depends, BackgroundTasks, Request
 from datetime import datetime, timezone
 from sqlalchemy import update, func, select
 import uuid
+import asyncio
 from db import AsyncSessionLocal
 from models import Interview, Response
 from schemas.interview_schema import StartInterviewRequest, EndInterviewRequest
@@ -10,7 +11,11 @@ from utils.redis_utils import create_session, set_session_meta
 from services.llm_service import llm_service
 import secrets
 from middleware.auth_middleware import safe_route
+from services.storage_service import storage_service
+from routers.media_router import _merge_video_background
+from utils.logger import get_logger
 
+logger = get_logger(__name__)
 router = APIRouter(prefix="/api/interview", tags=["sessions"])
 
 @router.post("/start-interview")
@@ -37,13 +42,6 @@ async def start_interview(request: StartInterviewRequest):
                     status_code=403,
                     detail="You have already completed this interview. Each candidate can only take the interview once."
                 )
-            
-            if interview.respondents and len(interview.respondents) > 0:
-                if email not in [r.lower().strip() for r in interview.respondents]:
-                    raise HTTPException(
-                        status_code=403,
-                        detail="Your email address is not authorized to take this interview. Please contact the HR team if you believe this is an error."
-                    )
         
         response = Response(
             interview_id=interview.id,
@@ -73,7 +71,7 @@ async def start_interview(request: StartInterviewRequest):
                 "started_at": datetime.now(timezone.utc).isoformat()
             })
         except Exception as e:
-            print(f"[ERROR] Redis session init failed: {e}")
+            logger.error(f"Redis session init failed: {e}", exc_info=True)
 
         duration_minutes = None
         if interview.time_duration and interview.time_duration.isdigit():
@@ -92,7 +90,8 @@ async def start_interview(request: StartInterviewRequest):
 
 @router.post("/end-interview")
 @safe_route
-async def end_interview(request: EndInterviewRequest):
+async def end_interview(request: EndInterviewRequest, http_request: Request, background_tasks: BackgroundTasks = BackgroundTasks()):
+    base_url = str(http_request.base_url)
     async with AsyncSessionLocal() as db:
         response = await get_response_or_404(db, request.response_id)
         interview = await get_interview_or_404(db, str(response.interview_id))
@@ -109,7 +108,7 @@ async def end_interview(request: EndInterviewRequest):
             duration_delta = response.end_time - response.start_time
             duration_seconds = int(duration_delta.total_seconds())
             response.duration = duration_seconds
-            print(f"[DEBUG] Interview duration calculated: {duration_seconds} seconds ({duration_seconds // 60}m {duration_seconds % 60}s)")
+            logger.debug(f"Interview duration calculated: {duration_seconds} seconds ({duration_seconds // 60}m {duration_seconds % 60}s)")
         
         qa_history = response.qa_history or []
         if len(qa_history) > 0:
@@ -123,25 +122,34 @@ async def end_interview(request: EndInterviewRequest):
                         try:
                             setattr(response, "overall_analysis", final_analysis)
                             
-                            if final_analysis and (not hasattr(response, 'status') or not response.status or response.status == "no_status"):
-                                score = final_analysis.get("overall_score", 0)
-                                if score >= 80:
-                                    response.status = "selected"
-                                elif score >= 60:
-                                    response.status = "potential"
-                                elif score < 40:
-                                    response.status = "not_selected"
-                                else:
-                                    response.status = "potential"
-                                response.status_source = "auto"
+                            # if final_analysis and (not hasattr(response, 'status') or not response.status or response.status == "no_status"):
+                            #     score = final_analysis.get("overall_score", 0)
+                            #     if score >= 80:
+                            #         response.status = "selected"
+                            #     elif score >= 60:
+                            #         response.status = "potential"
+                            #     elif score < 40:
+                            #         response.status = "not_selected"
+                            #     else:
+                            #         response.status = "potential"
+                            response.status_source = "manual"
                         except Exception as e:
-                            print(f"[WARN] Failed to set overall_analysis: {e}")
+                            logger.warning(f"Failed to set overall_analysis: {e}", exc_info=True)
                 except Exception as e:
-                    print(f"[WARN] Final analysis generation failed: {e}")
+                    logger.warning(f"Final analysis generation failed: {e}", exc_info=True)
         
         await db.commit()
         
+        logger.debug(f"Adding video merge task for response_id: {request.response_id}")
+        background_tasks.add_task(_merge_video_background, request.response_id, base_url)
+        logger.debug(f"Video merge task added to background for response_id: {request.response_id}")
+        
         if interview.question_mode == "dynamic":
+            try:
+                interview.llm_generated_questions = None
+                await db.commit()
+            except Exception:
+                pass
             total_questions = interview.question_count or 0
         else:
             questions_list = get_questions_list(interview)
@@ -157,6 +165,7 @@ async def end_interview(request: EndInterviewRequest):
             "total_questions": total_questions,
             "is_partially_complete": is_partially_complete,
             "end_time": response.end_time.isoformat() if response.end_time else None,
-            "duration_seconds": response.duration if response.duration else None
+            "duration_seconds": response.duration if response.duration else None,
+            "video_merge_started": True  # Indicate that video merge has been triggered
         }
 
diff --git a/backend/app/schemas/candidate_schema.py b/backend/app/schemas/candidate_schema.py
new file mode 100644
index 0000000..1195dde
--- /dev/null
+++ b/backend/app/schemas/candidate_schema.py
@@ -0,0 +1,11 @@
+from pydantic import BaseModel, EmailStr
+from typing import Optional
+from uuid import UUID
+
+
+class CreateCandidateRequest(BaseModel):
+    interview_id: UUID
+    name: str
+    email: EmailStr
+    phone_number: Optional[str] = None
+ 
\ No newline at end of file
diff --git a/backend/app/schemas/feedback_schema.py b/backend/app/schemas/feedback_schema.py
index 2b78973..809ae7d 100644
--- a/backend/app/schemas/feedback_schema.py
+++ b/backend/app/schemas/feedback_schema.py
@@ -7,6 +7,7 @@ from typing import Optional
 
 class CreateFeedbackRequest(BaseModel):
     interview_id: UUID
+    response_id: UUID
     email: Optional[EmailStr] = None
     feedback: str 
     satisfaction: int 
diff --git a/backend/app/schemas/interview_schema.py b/backend/app/schemas/interview_schema.py
index 68554a8..147dd71 100644
--- a/backend/app/schemas/interview_schema.py
+++ b/backend/app/schemas/interview_schema.py
@@ -20,7 +20,8 @@ class SubmitAnswerRequest(BaseModel):
 class InterviewResponse(BaseModel):
     id: str
     name: str
-    objective: str
+    job_description: str
+    department: str
     mode: str
     question_count: int
     context: Optional[Dict[str, Any]] = None
@@ -32,7 +33,8 @@ class InterviewResponse(BaseModel):
 
 class UpdateInterviewRequest(BaseModel):
     name: Optional[str] = None
-    objective: Optional[str] = None
+    job_description: Optional[str] = None
+    department: Optional[str] = None
     mode: Optional[str] = None  # 'predefined' | 'dynamic'
     question_count: Optional[int] = None
     auto_question_generate: Optional[bool] = None
@@ -60,4 +62,5 @@ class UpdateInterviewerRequest(BaseModel):
     is_active: Optional[bool] = None
 
 class DeleteInterviewerRequest(BaseModel):
-    interviewer_id: str
\ No newline at end of file
+    interviewer_id: str
+
diff --git a/backend/app/schemas/user_schema.py b/backend/app/schemas/user_schema.py
index 758789a..205d130 100644
--- a/backend/app/schemas/user_schema.py
+++ b/backend/app/schemas/user_schema.py
@@ -5,19 +5,16 @@ from typing import Optional
 from datetime import datetime
 from uuid import UUID
 
-
 class SignupRequest(BaseModel):
     first_name: str
     last_name: str
     email: EmailStr
     password: str 
 
-
 class LoginRequest(BaseModel):
     email: EmailStr
     password: str
 
-
 class UserResponse(BaseModel):
     id: UUID
     first_name: str
@@ -25,17 +22,14 @@ class UserResponse(BaseModel):
     email: EmailStr
     created_at: datetime
 
-
 class AuthResponse(BaseModel):
     access_token: str
     token_type: str = "bearer"
     user: UserResponse
 
-
 class ForgotPasswordRequest(BaseModel):
     email: EmailStr
 
-
 class ResetPasswordRequest(BaseModel):
     token: str
     new_password: str 
\ No newline at end of file
diff --git a/backend/app/services/feedback_service.py b/backend/app/services/feedback_service.py
deleted file mode 100644
index bd23c2b..0000000
--- a/backend/app/services/feedback_service.py
+++ /dev/null
@@ -1 +0,0 @@
-# Evaluation logic
\ No newline at end of file
diff --git a/backend/app/services/llm_service.py b/backend/app/services/llm_service.py
index 22cfd97..b4c25c8 100644
--- a/backend/app/services/llm_service.py
+++ b/backend/app/services/llm_service.py
@@ -12,6 +12,9 @@ from services.summarization_service import summarization_service
 from db import AsyncSessionLocal
 from models import Interview
 from sqlalchemy import select
+from utils.logger import get_logger
+
+logger = get_logger(__name__)
 
 class LLMService:
     def __init__(self):
@@ -85,10 +88,10 @@ class LLMService:
                 return await self._generate_dynamic_question(context_summary, difficulty_level)
                 
         except Exception as e:
-            print(f"Error generating questions: {str(e)}")
+            logger.error(f"Error generating questions: {str(e)}", exc_info=True)
             return []
     
-    async def _generate_predefined_questions(self, context_summary: str, question_count: int, difficulty_level: str = "medium", interview_objective: str = "", interview_name: str = "") -> Dict:
+    async def _generate_predefined_questions(self, context_summary: str, question_count: int, difficulty_level: str = "medium", job_description: str = "", interview_name: str = "") -> Dict:
         """
         Generate interview questions and description in one call, following Followup AI style.
         Returns a dict with 'questions' (list) and 'description' (str).
@@ -109,7 +112,7 @@ class LLMService:
         user_prompt = f"""Imagine you are an interviewer specialized in designing interview questions to help hiring managers find candidates with strong technical expertise and project experience, making it easier to identify the ideal fit for the role.
 
         Interview Title: {interview_name or 'Technical Interview'}
-        Interview Objective: {interview_objective or 'Technical skills assessment'}
+        Job Description: {job_description or 'Technical skills assessment'}
 
         Number of questions to be generated: {question_count}
 
@@ -279,7 +282,7 @@ class LLMService:
                 return question
                 
         except Exception as e:
-            print(f"Error generating next dynamic question: {str(e)}")
+            logger.error(f"Error generating next dynamic question: {str(e)}", exc_info=True)
             return {}
 
     async def analyze_response(self, interview_id: str, transcript: str, question_context: Dict) -> Dict:
@@ -302,10 +305,10 @@ class LLMService:
             
             return self._parse_json(response.choices[0].message.content)
         except Exception as e:
-            print(f"Error analyzing response: {str(e)}")
+            logger.error(f"Error analyzing response: {str(e)}", exc_info=True)
             raise
     
-    async def generate_insights(self, call_summaries: List[str], interview_name: str, interview_objective: str, interview_description: str) -> List[str]:
+    async def generate_insights(self, call_summaries: List[str], interview_name: str, job_description: str, interview_description: str) -> List[str]:
         """Generate insights from call summaries - Followup AI style"""
         try:
             system_prompt = "You are an expert in uncovering deeper insights from interview question and answer sets."
@@ -315,7 +318,7 @@ class LLMService:
             Call Summaries: {chr(10).join(f"- {s}" for s in call_summaries)}
 
             Interview Title: {interview_name}
-            Interview Objective: {interview_objective}
+            Job Description: {job_description}
             Interview Description: {interview_description}
 
             Output JSON: {{"insights": [string, string, string]}}"""
@@ -338,7 +341,7 @@ class LLMService:
             return [' '.join(str(i).split()[:25]) for i in insights[:3]]
             
         except Exception as e:
-            print(f"Error generating insights: {str(e)}")
+            logger.error(f"Error generating insights: {str(e)}", exc_info=True)
             return []
 
     async def generate_final_analysis(self, interview_id: str, qa_history: List[Dict]) -> Dict:
@@ -449,7 +452,7 @@ class LLMService:
                 return result
                 
         except Exception as e:
-            print(f"Error generating final analysis: {str(e)}")
+            logger.error(f"Error generating final analysis: {str(e)}", exc_info=True)
             raise
     
 
diff --git a/backend/app/services/question_service.py b/backend/app/services/question_service.py
index 78b1fbe..bbd5f4c 100644
--- a/backend/app/services/question_service.py
+++ b/backend/app/services/question_service.py
@@ -30,11 +30,11 @@ class QuestionService:
         context_for_llm: str
     ) -> Tuple[List[Dict], Optional[str]]:
         difficulty = QuestionService.get_difficulty_level(interview)
-        objective = interview.objective or ""
+        job_description = interview.job_description or ""
         name = interview.name or ""
         
         result = await llm_service._generate_predefined_questions(
-            context_for_llm, target_count, difficulty, objective, name
+            context_for_llm, target_count, difficulty, job_description, name
         )
         
         questions = [normalize_question(q) for q in result.get('questions', [])[:target_count]]
@@ -74,11 +74,11 @@ class QuestionService:
             return None
         
         difficulty_level = QuestionService.get_difficulty_level(interview)
-        interview_objective = interview.objective or ""
+        job_description = interview.job_description or ""
         interview_name = interview.name or ""
         
         result = await llm_service._generate_predefined_questions(
-            context_for_llm, 1, difficulty_level, interview_objective, interview_name
+            context_for_llm, 1, difficulty_level, job_description, interview_name
         )
         
         generated_description = result.get('description', '')
diff --git a/backend/app/services/storage_service.py b/backend/app/services/storage_service.py
index 710f598..c92f95d 100644
--- a/backend/app/services/storage_service.py
+++ b/backend/app/services/storage_service.py
@@ -1,43 +1,253 @@
-import os
-import uuid
+import shutil
+import re
+import subprocess
+import sys
 from pathlib import Path
-from typing import Tuple
 
+current_file = Path(__file__).resolve()
+app_dir = current_file.parent
+backend_dir = app_dir.parent
+if str(backend_dir) not in sys.path:
+    sys.path.insert(0, str(backend_dir))
+from config_loader import load_config
+from utils.logger import get_logger
+
+logger = get_logger(__name__)
 
 class StorageService:
-    def __init__(self, base_dir: str = None) -> None:
-        if base_dir is None:
-            project_root = Path(__file__).resolve().parents[2]
-            base_dir = project_root / "storage"
-        self.base_path = Path(base_dir)
-        self.images_path = self.base_path / "images"
-        self.videos_path = self.base_path / "videos"
-        self.images_path.mkdir(parents=True, exist_ok=True)
-        self.videos_path.mkdir(parents=True, exist_ok=True)
-
-    def _safe_extension(self, filename: str, allowed: Tuple[str, ...]) -> str:
-        ext = (Path(filename).suffix or "").lower()
-        if ext not in allowed:
-            return allowed[0]
-        return ext
-
-    def save_image(self, upload_filename: str, data: bytes) -> Path:
-        allowed = (".png", ".jpg", ".jpeg", ".webp")
-        ext = self._safe_extension(upload_filename, allowed)
-        file_id = uuid.uuid4().hex
-        path = self.images_path / f"{file_id}{ext}"
-        path.write_bytes(data)
-        return path
-
-    def save_video(self, upload_filename: str, data: bytes) -> Path:
-        allowed = (".webm", ".mp4", ".mkv")
-        ext = self._safe_extension(upload_filename, allowed)
-        file_id = uuid.uuid4().hex
-        path = self.videos_path / f"{file_id}{ext}"
-        path.write_bytes(data)
-        return path
+    def __init__(self):
+        config = load_config()
+        storage_type = config.get('storage', {}).get('storage_type', 'local')
+        
+        if storage_type == 'local':
+            storage_path = config.get('storage', {}).get('storage_path')
+            
+            if storage_path:
+                storage_path = Path(storage_path)
+                if storage_path.is_absolute():
+                    self.base_path = storage_path.resolve()
+                else:
+                    backend_dir = self._find_backend_directory()
+                    self.base_path = (backend_dir / storage_path).resolve()
+            else:
+                backend_dir = self._find_backend_directory()
+                self.base_path = (backend_dir / 'storage').resolve()
+        else:
+            self.base_path = Path("storage")
+        
+        self.temp_dir = self.base_path / "temp"
+        self.video_dir = self.base_path / "videos"
+        self.temp_dir.mkdir(parents=True, exist_ok=True)
+        self.video_dir.mkdir(parents=True, exist_ok=True)
+        
+    def _find_backend_directory(self) -> Path:
+        current_file = Path(__file__).resolve()
+        current_dir = current_file.parent
+        
+        for parent in [current_dir] + list(current_dir.parents):
+            config_file = parent / 'config.yaml'
+            if config_file.exists():
+                return parent
+        
+        if 'app' in current_dir.parts and 'services' in current_dir.parts:
+            app_index = current_dir.parts.index('app')
+            backend_parts = current_dir.parts[:app_index]
+            return Path(*backend_parts) if backend_parts else current_dir.parent.parent
+        
+        return current_dir.parent.parent
 
+    async def save_candidate_image(self, file_content: bytes, response_id: str, file_extension: str) -> str:
+        image_dir = self.base_path / "images"
+        image_dir.mkdir(parents=True, exist_ok=True)
+        file_path = image_dir / f"{response_id}.{file_extension}"
+        with open(file_path, "wb") as f:
+            f.write(file_content)
+        return f"images/{response_id}.{file_extension}"
+    
+    def _get_next_chunk_index(self, chunk_dir: Path, file_extension: str, proposed_index: int = None) -> int:
+        """Get the next available chunk index."""
+        if proposed_index is None:
+            existing = sorted(chunk_dir.glob(f"chunk_*.{file_extension}"))
+            return len(existing)
+        
+        proposed_path = chunk_dir / f"chunk_{proposed_index:05d}.{file_extension}"
+        if not proposed_path.exists():
+            return proposed_index
+        
+        existing = sorted(chunk_dir.glob(f"chunk_*.{file_extension}"))
+        max_index = -1
+        for f in existing:
+            match = re.search(r'chunk_(\d+)', f.name)
+            if match:
+                max_index = max(max_index, int(match.group(1)))
+        return max_index + 1
 
-storage_service = StorageService()
+    async def save_chunk(self, file_content: bytes, response_id: str, file_extension: str, chunk_index: int = None) -> str:
+        """Save a video chunk to temporary storage."""
+        chunk_dir = self.temp_dir / response_id
+        chunk_dir.mkdir(parents=True, exist_ok=True)
+
+        chunk_index = self._get_next_chunk_index(chunk_dir, file_extension, chunk_index)
+        file_path = chunk_dir / f"chunk_{chunk_index:05d}.{file_extension}"
+        
+        if file_extension.lower() == "webm" and chunk_index == 0 and len(file_content) >= 4:
+            if file_content[0:4] != b'\x1a\x45\xdf\xa3':
+                pass  
+        
+        with open(file_path, "wb") as f:
+            f.write(file_content)
+        
+        saved_size = file_path.stat().st_size
+        if saved_size != len(file_content):
+            raise IOError(f"File size mismatch: expected {len(file_content)} bytes, got {saved_size} bytes")
+
+        return str(file_path)
+
+    def _find_all_chunks(self, temp_response_dir: Path):
+        all_chunks = sorted(
+            temp_response_dir.glob("chunk_*.webm"),
+            key=lambda f: int(re.search(r'chunk_(\d+)', f.name).group(1))
+        )
+        
+        valid_chunks = []
+        for chunk_file in all_chunks:
+            try:
+                size = chunk_file.stat().st_size
+                if size < 100:  
+                    continue
+                
+                with open(chunk_file, "rb") as f:
+                    header = f.read(4)
+                    if len(header) < 4:
+                        continue
+                
+                valid_chunks.append(chunk_file)
+            except Exception:
+                continue  # Skip invalid chunks silently
+        
+        return valid_chunks
+
+    def _get_video_url(self, response_id: str, base_url: str = None) -> str:
+        url = f"/api/media/files/videos/{response_id}.mp4"
+        url = url.replace('//', '/')
+        return url
+
+    def _validate_chunks(self, chunks: list) -> bool:
+        if not chunks:
+            return False
+        
+        chunk_indices = [int(re.search(r'chunk_(\d+)', c.name).group(1)) for c in chunks]
+        if 0 not in chunk_indices:
+            return False
+        
+        if len(chunks) == 1 and chunks[0].stat().st_size < 100_000:
+            return False
+        
+        return True
 
+    def _merge_chunks_to_webm(self, chunks: list, merged_webm: Path) -> bool:
+        try:
+            with open(merged_webm, "wb") as outfile:
+                for chunk_file in chunks:
+                    with open(chunk_file, "rb") as infile:
+                        outfile.write(infile.read())
+            
+            with open(merged_webm, "rb") as f:
+                if f.read(4) != b'\x1a\x45\xdf\xa3':
+                    return False
+            return True
+        except Exception:
+            return False
 
+    def _build_ffmpeg_command(self, merged_webm: Path, output_path: Path) -> list:
+        """Build FFmpeg command for WebM to MP4 conversion."""
+        return [
+            "ffmpeg",
+            "-analyzeduration", "2147483647",
+            "-probesize", "2147483647",
+            "-fflags", "+genpts+igndts+discardcorrupt",
+            "-err_detect", "ignore_err",
+            "-i", str(merged_webm),
+            "-c:v", "libx264", "-preset", "fast", "-crf", "23",
+            "-c:a", "aac", "-b:a", "128k",
+            "-movflags", "+faststart",
+            "-avoid_negative_ts", "make_zero",
+            "-fps_mode", "vfr",
+            "-f", "mp4",
+            "-y",
+            str(output_path)
+        ]
+
+    def _validate_output_video(self, output_path: Path) -> bool:
+        if not output_path.exists():
+            return False
+        
+        if output_path.stat().st_size == 0:
+            return False
+        
+        try:
+            probe_cmd = [
+                "ffprobe", "-v", "error", "-show_entries", "format=duration",
+                "-of", "default=noprint_wrappers=1:nokey=1", str(output_path)
+            ]
+            probe_result = subprocess.run(probe_cmd, capture_output=True, text=True, timeout=10)
+            if probe_result.returncode == 0:
+                duration = float(probe_result.stdout.strip().split('\n')[0] or 0)
+                return duration > 0
+        except Exception:
+            pass
+        
+        return True
+
+    async def save_candidate_video(self, response_id: str, base_url: str = None, file_extension: str = "webm") -> str:
+        output_path = self.video_dir / f"{response_id}.mp4"
+        
+        if output_path.exists() and output_path.stat().st_size > 0:
+            logger.info(f"Video already exists: {output_path}, size: {output_path.stat().st_size} bytes")
+            return self._get_video_url(response_id, base_url)
+        
+        temp_response_dir = self.temp_dir / response_id
+        if not temp_response_dir.exists():
+            logger.warning(f"Temp directory not found: {temp_response_dir}")
+            return None
+        
+        chunks = self._find_all_chunks(temp_response_dir)
+        logger.info(f"Found {len(chunks)} chunks for response_id: {response_id}")
+        if not self._validate_chunks(chunks):
+            logger.warning(f"Chunks validation failed for response_id: {response_id}")
+            return None
+        
+        merged_webm = temp_response_dir / "merged.webm"
+        if not self._merge_chunks_to_webm(chunks, merged_webm):
+            logger.error(f"Failed to merge chunks to WebM for response_id: {response_id}")
+            return None
+
+        ffmpeg_cmd = self._build_ffmpeg_command(merged_webm, output_path)
+        logger.info(f"Running FFmpeg to convert WebM to MP4: {output_path}")
+        
+        try:
+            result = subprocess.run(ffmpeg_cmd, check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, timeout=600)
+            logger.info(f"FFmpeg completed successfully for response_id: {response_id}")
+            
+            if not self._validate_output_video(output_path):
+                logger.error(f"Output video validation failed for response_id: {response_id}")
+                return None
+            
+            logger.info(f"Video successfully created: {output_path}, size: {output_path.stat().st_size} bytes")
+            shutil.rmtree(temp_response_dir, ignore_errors=True)
+            
+            return self._get_video_url(response_id, base_url)
+            
+        except subprocess.TimeoutExpired:
+            logger.error(f"FFmpeg timeout for response_id: {response_id}")
+            return None
+        except subprocess.CalledProcessError as e:
+            error_msg = e.stderr.decode() if e.stderr else str(e)
+            logger.error(f"FFmpeg failed for response_id: {response_id}, error: {error_msg}")
+            return None
+        except Exception as e:
+            logger.error(f"Unexpected error during video conversion for response_id: {response_id}: {e}", exc_info=True)
+            return None
+
+
+storage_service = StorageService()
diff --git a/backend/app/services/stt_service.py b/backend/app/services/stt_service.py
index c04e950..1517926 100644
--- a/backend/app/services/stt_service.py
+++ b/backend/app/services/stt_service.py
@@ -6,6 +6,7 @@ import asyncio
 from typing import AsyncIterator, Optional, List
 from utils.redis_utils import get_audio_chunks
 from utils import audio_utils
+from config_loader import load_config
 
 
 class STTProvider:
@@ -130,7 +131,25 @@ class DeepgramProvider(STTProvider):
 
 class STTService:
     def __init__(self, provider: Optional[STTProvider] = None):
-        self.provider = provider or DeepgramProvider()
+        self.config = load_config()
+        provider_name = self.config.get('stt', {}).get('provider')
+        
+        provider_name_lower = provider_name.lower().strip() if provider_name else ''
+        provider_map = {
+            'deepgram': DeepgramProvider,
+            'deepgram_provider': DeepgramProvider,
+            'azure_whisper': AzureWhisperProvider,
+            'azure': AzureWhisperProvider,  # Allow shorthand
+        }
+        
+        provider_class = provider_map.get(provider_name_lower)
+        if not provider_class:
+            raise ValueError(
+                f"Unknown STT provider: {provider_name}. "
+                f"Available providers: {', '.join(set(provider_map.keys()))}"
+            )
+        
+        self.provider = provider_class()
 
     async def transcribe_session(self, session_id: str, language: Optional[str] = None) -> str:
         chunks: List[bytes] = await get_audio_chunks(session_id)
diff --git a/backend/app/services/summarization_service.py b/backend/app/services/summarization_service.py
index 9a7fbcc..7dbdfca 100644
--- a/backend/app/services/summarization_service.py
+++ b/backend/app/services/summarization_service.py
@@ -9,6 +9,9 @@ from config_loader import load_config
 from openai import AsyncOpenAI
 from openai import AsyncAzureOpenAI
 import re
+from utils.logger import get_logger
+
+logger = get_logger(__name__)
 
 class SummarizationService:
     def __init__(self):
@@ -82,7 +85,7 @@ class SummarizationService:
             return summary_data
 
         except Exception as e:
-            print(f"Error summarizing JD: {str(e)}")
+            logger.error(f"Error summarizing JD: {str(e)}", exc_info=True)
             return {
                 "summary_text": "Software developer position requiring technical skills.",
                 "skills": ["Python", "FastAPI", "PostgreSQL"],
diff --git a/backend/app/services/tts_service.py b/backend/app/services/tts_service.py
index 5086d81..804674e 100644
--- a/backend/app/services/tts_service.py
+++ b/backend/app/services/tts_service.py
@@ -69,7 +69,23 @@ class ElevenLabsProvider(TTSProvider):
 
 class TTSService:
     def __init__(self, provider: Optional[TTSProvider] = None):
-        self.provider = provider or ElevenLabsProvider()
+        self.config = load_config()
+        provider_name = self.config.get('tts', {}).get('provider')
+        
+        provider_name_lower = provider_name.lower().strip() if provider_name else ''
+        provider_map = {
+            'elevenlabs': ElevenLabsProvider,
+            'elevenlabs_provider': ElevenLabsProvider,
+        }
+        
+        provider_class = provider_map.get(provider_name_lower)
+        if not provider_class:
+            raise ValueError(
+                f"Unknown TTS provider: {provider_name}. "
+                f"Available providers: {', '.join(set(provider_map.keys()))}"
+            )
+        
+        self.provider = provider_class()
 
     async def synthesize(self, text: str, voice_id: Optional[str] = None, audio_format: str = "mp3") -> bytes:
         return await self.provider.synthesize(text, voice_id, audio_format)
diff --git a/backend/app/sockets/interview_socket.py b/backend/app/sockets/interview_socket.py
index dc2bf37..b8619d6 100644
--- a/backend/app/sockets/interview_socket.py
+++ b/backend/app/sockets/interview_socket.py
@@ -5,7 +5,12 @@ from sqlalchemy import select
 from db import AsyncSessionLocal
 from models import Response
 import asyncio
+import base64
+import re
+from services.storage_service import storage_service
+from utils.logger import get_logger
 
+logger = get_logger(__name__)
 sio = socketio.AsyncServer(async_mode="asgi", cors_allowed_origins="*")
 _sessions = {}
 
@@ -56,8 +61,8 @@ async def start_interview(sid, data):
         
         if not interview:
             return {"ok": False, "error": f"Interview with id {interview_id} not found"}
-        
-        if not interview.is_active:
+
+        if not interview.is_open:
             return {"ok": False, "error": "Interview is not active"}
     
 
@@ -82,6 +87,11 @@ async def start_interview(sid, data):
             except asyncio.CancelledError:
                 break
         
+    old_session = _sessions.get(sid)
+    if old_session:
+        logger.debug(f"Cleaning up existing session for sid {sid} before creating new one")
+        await _cleanup_session(sid)
+    
     emitter_task = asyncio.create_task(transcript_emitter(sid, transcript_queue))
     stt_task = asyncio.create_task(stt_service.stream_transcribe_session(audio_queue, transcript_queue))
     
@@ -139,7 +149,6 @@ async def end_interview(sid, data=None):
                 pass
             except Exception:
                 pass
-
     try:
         final_text = await stt_service.transcribe_session(session_id)
         await sio.emit("transcript_result", {"text": final_text}, to=sid)
@@ -165,4 +174,64 @@ async def end_interview(sid, data=None):
             await sio.leave_room(sid, session_id)
         except Exception:
             pass
-        _sessions.pop(sid, None)
\ No newline at end of file
+        _sessions.pop(sid, None)
+
+@sio.event
+async def save_video_chunk(sid, data):
+    response_id = data.get("response_id")
+    chunk = data.get("chunk")
+    file_extension = data.get("file_extension", "webm")
+    chunk_index = data.get("chunk_index", 0)
+
+    if chunk_index == 0:
+        logger.info(f"CRITICAL: Received chunk 0 (EBML header) for response_id: {response_id}")
+    else:
+        logger.debug(f"Received chunk {chunk_index} for response_id: {response_id}")
+
+    if not chunk or not response_id:
+        error_msg = f"Missing response_id or chunk (chunk_index: {chunk_index})"
+        await sio.emit("error", {"error": error_msg}, to=sid)
+        return
+
+    try:
+        if isinstance(chunk, str) and chunk.startswith("data:"):
+            chunk = chunk.split(",", 1)[1]
+        
+        if not isinstance(chunk, str):
+            raise ValueError(f"Chunk data must be a string, got {type(chunk)}")
+        
+        chunk = chunk.strip().replace('\n', '').replace('\r', '').replace(' ', '')
+        try:
+            if chunk_index == 0:
+                logger.debug(f"Chunk 0 base64 string length: {len(chunk)}, first 20 chars: {chunk[:20]}...")
+            
+            chunk_bytes = base64.b64decode(chunk, validate=True)
+        except Exception as e:
+            raise ValueError(f"Invalid base64 encoding: {str(e)}")
+
+        if len(chunk_bytes) < 50:
+            raise ValueError(f"Invalid chunk size: {len(chunk_bytes)} bytes (minimum: 50 bytes)")
+        
+        if chunk_index == 0:
+            header_info = chunk_bytes[0:4].hex() if len(chunk_bytes) >= 4 else 'N/A'
+            if len(chunk_bytes) >= 4:
+                expected_header = b'\x1a\x45\xdf\xa3'
+                actual_header = chunk_bytes[0:4]
+                if actual_header == expected_header:
+                    logger.debug(f"Chunk 0 has valid EBML header")
+                else:
+                    logger.warning(f"Chunk 0 EBML header mismatch: expected {expected_header.hex()}, got {actual_header.hex()}")
+        else:
+            logger.debug(f"Decoded chunk {chunk_index}: {len(chunk_bytes)} bytes, first 4 bytes: {chunk_bytes[0:4].hex() if len(chunk_bytes) >= 4 else 'N/A'}")
+
+        saved_path = await storage_service.save_chunk(
+            chunk_bytes, response_id, file_extension, chunk_index
+        )
+        if chunk_index == 0:
+            logger.info(f"CRITICAL chunk 0 saved -> {saved_path}")
+        else:
+            logger.debug(f"Chunk #{chunk_index:05d} saved -> {saved_path}")
+        await sio.emit("video_chunk_saved", {"ok": True, "index": chunk_index}, to=sid)
+
+    except Exception as e:
+        await sio.emit("error", {"error": str(e)}, to=sid)
diff --git a/backend/app/utils/decorators.py b/backend/app/utils/decorators.py
deleted file mode 100644
index 0382ab1..0000000
--- a/backend/app/utils/decorators.py
+++ /dev/null
@@ -1,18 +0,0 @@
-# Common decorators for route handlers
-
-from functools import wraps
-from fastapi import HTTPException
-
-
-def safe_route(func):
-    @wraps(func)
-    async def wrapper(*args, **kwargs):
-        try:
-            return await func(*args, **kwargs)
-        except HTTPException:
-            raise  
-        except Exception as e:
-            print(f"[ERROR] {func.__name__} failed: {e}")
-            raise HTTPException(status_code=500, detail=str(e))
-    return wrapper
-
diff --git a/backend/app/utils/file_utils.py b/backend/app/utils/file_utils.py
deleted file mode 100644
index b51d026..0000000
--- a/backend/app/utils/file_utils.py
+++ /dev/null
@@ -1 +0,0 @@
-# For saving/loading media or transcripts
\ No newline at end of file
diff --git a/backend/app/utils/interview_utils.py b/backend/app/utils/interview_utils.py
index 0e106c4..058b7db 100644
--- a/backend/app/utils/interview_utils.py
+++ b/backend/app/utils/interview_utils.py
@@ -11,6 +11,9 @@ from sqlalchemy.ext.asyncio import AsyncSession
 from sqlalchemy import select
 from models import Interview, Response
 from services.tts_service import tts_service
+from utils.logger import get_logger
+
+logger = get_logger(__name__)
 
 def _remove_text_field(questions: list) -> list:
     if not questions:
@@ -71,7 +74,7 @@ async def synthesize_tts(q_text: str, voice_id: Optional[str] = None) -> Optiona
             "tts_content_type": "audio/mpeg",
         }
     except Exception as e:
-        print(f"[WARN] TTS failed: {e}")
+        logger.warning(f"TTS failed: {e}", exc_info=True)
         return None
 
 async def get_interview_or_404(db: AsyncSession, interview_id: str) -> Interview:
diff --git a/backend/app/utils/logger.py b/backend/app/utils/logger.py
index b415893..b9410ca 100644
--- a/backend/app/utils/logger.py
+++ b/backend/app/utils/logger.py
@@ -1 +1,99 @@
-# Centralized logging
+#centralized logger setup for the application
+
+import logging
+import sys
+from pathlib import Path
+from logging.handlers import RotatingFileHandler
+from typing import Optional
+import os
+from dotenv import load_dotenv
+load_dotenv()
+
+def setup_logger(
+    name: str = "ai_interview_tool",
+    log_level: str = "INFO",
+    log_file: Optional[str] = None,
+    max_bytes: int = 10 * 1024 * 1024,  # 10MB
+    backup_count: int = 5
+) -> logging.Logger:
+    """
+    Set up a centralized logger for the application.
+    
+    Args:
+        name: Logger name
+        log_level: Logging level (DEBUG, INFO, WARNING, ERROR, CRITICAL)
+        log_file: Optional path to log file. If None, logs only to console.
+        max_bytes: Maximum size of log file before rotation
+        backup_count: Number of backup log files to keep
+    
+    Returns:
+        Configured logger instance
+    """
+    logger = logging.getLogger(name)
+    
+    if logger.handlers:
+        return logger
+    
+    level = getattr(logging, log_level.upper(), logging.INFO)
+    logger.setLevel(level)
+    
+    formatter = logging.Formatter(
+        fmt='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
+        datefmt='%Y-%m-%d %H:%M:%S'
+    )
+    
+    console_handler = logging.StreamHandler(sys.stdout)
+    console_handler.setLevel(level)
+    console_handler.setFormatter(formatter)
+    logger.addHandler(console_handler)
+    
+    if log_file:
+        log_path = Path(log_file)
+        log_path.parent.mkdir(parents=True, exist_ok=True)
+        
+        file_handler = RotatingFileHandler(
+            log_file,
+            maxBytes=max_bytes,
+            backupCount=backup_count,
+            encoding='utf-8'
+        )
+        file_handler.setLevel(level)
+        file_handler.setFormatter(formatter)
+        logger.addHandler(file_handler)
+    
+    return logger
+
+
+def get_logger(name: Optional[str] = None) -> logging.Logger:
+    """
+    Get a logger instance. If name is provided, creates a child logger.
+    Otherwise returns the default application logger.
+    
+    Usage:
+        from utils.logger import get_logger
+        logger = get_logger(__name__)
+        logger.info("This is an info message")
+        logger.error("This is an error message")
+    """
+    
+    log_level = os.getenv("LOG_LEVEL", "INFO")
+    log_file = os.getenv("LOG_FILE", None)
+    
+    # If LOG_FILE is not set, use default path in cache/logs
+    if log_file is None:
+        current_file = Path(__file__).resolve()
+        app_dir = current_file.parent.parent  # Go up from utils/ to app/
+        log_file = str(app_dir / "cache" / "logs" / "app.log")
+    
+    main_logger = setup_logger(
+        name="ai_interview_tool",
+        log_level=log_level,
+        log_file=log_file
+    )
+    
+    if name:
+        return main_logger.getChild(name)
+    return main_logger
+
+
+logger = get_logger()
diff --git a/backend/app/utils/user_auth.py b/backend/app/utils/user_auth.py
index cca414d..bbfc005 100644
--- a/backend/app/utils/user_auth.py
+++ b/backend/app/utils/user_auth.py
@@ -6,6 +6,9 @@ import jwt
 import os
 import smtplib
 from email.message import EmailMessage
+from utils.logger import get_logger
+
+logger = get_logger(__name__)
 
 
 _pwd_context = CryptContext(schemes=["bcrypt_sha256", "bcrypt"], deprecated="auto")
@@ -45,7 +48,7 @@ def send_email(to_email: str, subject: str, body_text: str) -> None:
     from_email = os.getenv("SMTP_FROM", user or "no-reply@example.com")
 
     if not host or not user or not password:
-        print(f"[EMAIL_FALLBACK] To: {to_email}\nSubject: {subject}\n\n{body_text}")
+        logger.info(f"EMAIL_FALLBACK - To: {to_email}, Subject: {subject}")
         return
 
     msg = EmailMessage()
diff --git a/backend/config.yaml b/backend/config.yaml
index 74b63ab..0634fd7 100644
--- a/backend/config.yaml
+++ b/backend/config.yaml
@@ -17,8 +17,12 @@ tts:
   api_key: ${ELEVENLABS_API_KEY}
   voice_id: ${ELEVENLABS_VOICE_ID}
 
-interview:
-  default_question_mode: "predefined"  # Switch this to "dynamic"
-  predefined_questions: 5
-  dynamic_max_questions: 10
-  context_summarization: true
\ No newline at end of file
+# interview:
+#   default_question_mode: "predefined"  # Switch this to "dynamic"
+#   predefined_questions: 5
+#   dynamic_max_questions: 10
+#   context_summarization: true
+
+storage:
+  storage_type: local  # "local" or "s3"
+  storage_path: storage  # Relative to backend directory, or absolute path
\ No newline at end of file
diff --git a/backend/create_tables.py b/backend/create_tables.py
index fecb915..4b73a75 100644
--- a/backend/create_tables.py
+++ b/backend/create_tables.py
@@ -15,6 +15,8 @@ engine = create_async_engine(os.getenv("DATABASE_URL"), echo=True)
 async def create_tables():
     async with engine.begin() as conn:
         await conn.run_sync(Base.metadata.create_all)
-    print("Tables created successfully!")
+    from app.utils.logger import get_logger
+    logger = get_logger(__name__)
+    logger.info("Tables created successfully!")
 
 asyncio.run(create_tables())
diff --git a/backend/requirements.txt b/backend/requirements.txt
index 9302bca..84f5159 100644
--- a/backend/requirements.txt
+++ b/backend/requirements.txt
@@ -17,4 +17,7 @@ python-multipart
 email-validator
 passlib
 PyJWT
-bcrypt==4.3.0
\ No newline at end of file
+bcrypt==4.3.0
+boto3==1.28.39
+pandas>=2.0.0
+openpyxl>=3.0.0
\ No newline at end of file
diff --git a/frontend/src/App.tsx b/frontend/src/App.tsx
index 9d3ae77..1c87104 100644
--- a/frontend/src/App.tsx
+++ b/frontend/src/App.tsx
@@ -8,6 +8,7 @@ import CandidateStart from './components/CandidateStart';
 import InterviewsList from './components/InterviewsList';
 import InterviewersList from './components/InterviewersList';
 import CreateInterviewer from './components/CreateInterviewer';
+import Candidates from './components/Candidates';
 
 type Step = 'create' | 'upload' | 'interview';
 
@@ -48,6 +49,9 @@ function App() {
     if (parts[2] === 'responses' && parts[3]) {
       return <CandidateAnalytics apiBaseUrl={apiBaseUrl} interviewId={iid} responseId={parts[3]} />
     }
+    if (parts[2] === 'candidates') {
+      return <Candidates apiBaseUrl={apiBaseUrl} interviewId={iid} />
+    }
     return <InterviewDetail apiBaseUrl={apiBaseUrl} interviewId={iid} />
   }
 
@@ -63,11 +67,13 @@ function App() {
   }
 
   if (parts[0] === 'create') {
+    const urlParams = new URLSearchParams(window.location.search);
+    const editId = urlParams.get('edit');
     const onInterviewCreated = (id: string) => {
       window.history.pushState({}, '', `/interviews/${id}`);
       window.dispatchEvent(new PopStateEvent('popstate'));
     };
-    return <CreateInterview onInterviewCreated={onInterviewCreated} apiBaseUrl={apiBaseUrl} />
+    return <CreateInterview onInterviewCreated={onInterviewCreated} apiBaseUrl={apiBaseUrl} interviewId={editId || undefined} />
   }
 
   // Default: interviews grid
diff --git a/frontend/src/components/AddCandidateDialog.tsx b/frontend/src/components/AddCandidateDialog.tsx
new file mode 100644
index 0000000..23a6c76
--- /dev/null
+++ b/frontend/src/components/AddCandidateDialog.tsx
@@ -0,0 +1,550 @@
+import { useState, useRef, useEffect } from 'react';
+import { X, Upload, Download, UserPlus, Mail, CheckCircle } from 'lucide-react';
+import { getApiHeaders } from '../utils/api';
+
+interface AddCandidateDialogProps {
+  interviewId: string;
+  apiBaseUrl: string;
+  onClose: () => void;
+  onSuccess?: () => void;
+}
+
+export default function AddCandidateDialog({
+  interviewId,
+  apiBaseUrl,
+  onClose,
+  onSuccess,
+}: AddCandidateDialogProps) {
+  const [activeTab, setActiveTab] = useState<'manual' | 'bulk' | 'existing'>('manual');
+  const [loading, setLoading] = useState(false);
+  const [error, setError] = useState('');
+  const [success, setSuccess] = useState('');
+  
+  // Manual entry fields
+  const [name, setName] = useState('');
+  const [email, setEmail] = useState('');
+  const [phoneNumber, setPhoneNumber] = useState('');
+  
+  // Bulk upload
+  const [uploadFile, setUploadFile] = useState<File | null>(null);
+  const fileInputRef = useRef<HTMLInputElement>(null);
+  
+  // Existing candidates
+  const [existingCandidates, setExistingCandidates] = useState<any[]>([]);
+  const [loadingCandidates, setLoadingCandidates] = useState(false);
+  const [sendingInviteTo, setSendingInviteTo] = useState<string | null>(null);
+  
+  // Load existing candidates when dialog opens
+  useEffect(() => {
+    loadExistingCandidates();
+  }, [interviewId, apiBaseUrl]);
+  
+  const loadExistingCandidates = async () => {
+    setLoadingCandidates(true);
+    try {
+      const response = await fetch(`${apiBaseUrl}/api/interview/list-candidates?interview_id=${interviewId}`, {
+        method: 'GET',
+        headers: getApiHeaders(false),
+      });
+      if (response.ok) {
+        const data = await response.json();
+        if (data.ok) {
+          setExistingCandidates(data.candidates || []);
+        }
+      }
+    } catch (err) {
+      console.error('Failed to load candidates:', err);
+    } finally {
+      setLoadingCandidates(false);
+    }
+  };
+  
+  // Helper function to send invite by email or candidate_id
+  const sendInviteToCandidate = async (email?: string, candidateId?: string): Promise<boolean> => {
+    const formData = new FormData();
+    formData.append('interview_id', interviewId);
+    if (candidateId) {
+      formData.append('candidate_id', candidateId);
+    } else if (email) {
+      formData.append('email', email.trim());
+    } else {
+      throw new Error('Either email or candidate_id must be provided');
+    }
+    
+    const response = await fetch(`${apiBaseUrl}/api/interview/send-invite`, {
+      method: 'POST',
+      headers: getApiHeaders(false),
+      body: formData,
+    });
+    
+    if (!response.ok) {
+      const errorData = await response.json();
+      throw new Error(errorData.detail || 'Failed to send invite');
+    }
+    
+    const data = await response.json();
+    return data.invite_sent === true;
+  };
+
+  const handleSendInviteToExisting = async (candidateEmail: string, candidateId?: string) => {
+    setSendingInviteTo(candidateEmail);
+    try {
+      await sendInviteToCandidate(candidateEmail, candidateId);
+      await loadExistingCandidates();
+      setSuccess(`Invite sent successfully to ${candidateEmail}!`);
+    } catch (err: any) {
+      setError(err.message || 'Failed to send invite');
+    } finally {
+      setSendingInviteTo(null);
+    }
+  };
+
+  const handleAddCandidate = async (sendInvite: boolean = false) => {
+    if (activeTab === 'manual') {
+      if (!name.trim() || !email.trim()) {
+        setError('Name and Email are required');
+        return;
+      }
+      
+      setLoading(true);
+      setError('');
+      setSuccess('');
+      
+      try {
+        // Add candidate (no invite sent here)
+        const response = await fetch(`${apiBaseUrl}/api/interview/add-candidate`, {
+          method: 'POST',
+          headers: getApiHeaders(),
+          body: JSON.stringify({
+            interview_id: interviewId,
+            name: name.trim(),
+            email: email.trim(),
+            phone_number: phoneNumber.trim() || null,
+          }),
+        });
+        
+        if (!response.ok) {
+          const errorData = await response.json();
+          // If duplicate and sendInvite, send invite to existing candidate
+          if (response.status === 409 && sendInvite) {
+            try {
+              const sent = await sendInviteToCandidate(email.trim());
+              if (sent) {
+                setSuccess('Candidate already exists. Invite sent successfully!');
+                await loadExistingCandidates();
+                if (onSuccess) onSuccess();
+                return;
+              }
+            } catch (inviteErr: any) {
+              throw new Error(errorData.detail || 'Failed to send invite to existing candidate');
+            }
+          }
+          throw new Error(errorData.detail || 'Failed to add candidate');
+        }
+        
+        const data = await response.json();
+        
+        // If sendInvite is true, send invite after adding
+        if (sendInvite && data.candidate) {
+          try {
+            const sent = await sendInviteToCandidate(email.trim());
+            if (sent) {
+              setSuccess('Candidate added and invite sent successfully!');
+            } else {
+              setSuccess('Candidate added but failed to send invite.');
+            }
+          } catch (inviteErr: any) {
+            setSuccess('Candidate added but failed to send invite.');
+          }
+        } else {
+          setSuccess('Candidate added successfully!');
+        }
+        
+        // Clear fields only after sending invite
+        if (sendInvite) {
+          setName('');
+          setEmail('');
+          setPhoneNumber('');
+        }
+        
+        await loadExistingCandidates();
+        if (onSuccess) onSuccess();
+      } catch (err: any) {
+        setError(err.message || 'Failed to add candidate');
+      } finally {
+        setLoading(false);
+      }
+    } else {
+      // Bulk upload
+      if (!uploadFile) {
+        setError('Please select a file to upload');
+        return;
+      }
+      
+      setLoading(true);
+      setError('');
+      setSuccess('');
+      
+      try {
+        const formData = new FormData();
+        formData.append('interview_id', interviewId);
+        formData.append('file', uploadFile);
+        
+        const response = await fetch(`${apiBaseUrl}/api/interview/bulk-upload`, {
+          method: 'POST',
+          headers: getApiHeaders(false),
+          body: formData,
+        });
+        
+        if (!response.ok) {
+          const errorData = await response.json();
+          throw new Error(errorData.detail || 'Failed to upload candidates');
+        }
+        
+        const data = await response.json();
+        const createdCount = data.created?.length || 0;
+        const skippedCount = data.skipped?.length || 0;
+        
+        // If sendInvite is true, send invites to all created candidates
+        if (sendInvite && createdCount > 0) {
+          let invitesSent = 0;
+          let inviteFailed = 0;
+          
+          for (const candidate of data.created) {
+            try {
+              const sent = await sendInviteToCandidate(undefined, candidate.id);
+              if (sent) {
+                invitesSent++;
+              } else {
+                inviteFailed++;
+              }
+            } catch {
+              inviteFailed++;
+            }
+          }
+          
+          if (invitesSent > 0) {
+            setSuccess(
+              `Successfully added ${createdCount} candidate(s). ` +
+              `Invites sent: ${invitesSent}${inviteFailed > 0 ? ` (${inviteFailed} failed)` : ''}. ` +
+              `${skippedCount} skipped.`
+            );
+          } else {
+            setSuccess(`Successfully added ${createdCount} candidate(s) but failed to send invites. ${skippedCount} skipped.`);
+          }
+        } else {
+          setSuccess(`Successfully added ${createdCount} candidate(s). ${skippedCount} skipped.`);
+        }
+        
+        // Reset upload
+        setUploadFile(null);
+        if (fileInputRef.current) {
+          fileInputRef.current.value = '';
+        }
+        
+        // Reload existing candidates after bulk upload
+        await loadExistingCandidates();
+        
+        if (onSuccess) {
+          onSuccess();
+        }
+      } catch (err: any) {
+        setError(err.message || 'Failed to upload candidates');
+      } finally {
+        setLoading(false);
+      }
+    }
+  };
+
+  const handleFileSelect = (e: React.ChangeEvent<HTMLInputElement>) => {
+    const file = e.target.files?.[0];
+    if (file) {
+      const ext = file.name.toLowerCase().split('.').pop();
+      if (ext !== 'csv' && ext !== 'xlsx') {
+        setError('Please select a .csv or .xlsx file');
+        return;
+      }
+      setUploadFile(file);
+      setError('');
+    }
+  };
+
+  const handleDragOver = (e: React.DragEvent) => {
+    e.preventDefault();
+    e.stopPropagation();
+  };
+
+  const handleDrop = (e: React.DragEvent) => {
+    e.preventDefault();
+    e.stopPropagation();
+    const file = e.dataTransfer.files?.[0];
+    if (file) {
+      const ext = file.name.toLowerCase().split('.').pop();
+      if (ext !== 'csv' && ext !== 'xlsx') {
+        setError('Please select a .csv or .xlsx file');
+        return;
+      }
+      setUploadFile(file);
+      setError('');
+    }
+  };
+
+  const downloadSampleCSV = () => {
+    const csvContent = 'Name,Email,Phone Number\nJohn Doe,john.doe@example.com,+1 2345678900\nJane Smith,jane.smith@example.com,+1 2345678901';
+    const blob = new Blob([csvContent], { type: 'text/csv' });
+    const url = window.URL.createObjectURL(blob);
+    const a = document.createElement('a');
+    a.href = url;
+    a.download = 'sample_candidates.csv';
+    document.body.appendChild(a);
+    a.click();
+    document.body.removeChild(a);
+    window.URL.revokeObjectURL(url);
+  };
+
+  return (
+    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4" onClick={onClose}>
+      <div className="bg-white rounded-lg max-w-2xl w-full max-h-[90vh] overflow-y-auto" onClick={(e) => e.stopPropagation()}>
+        {/* Header */}
+        <div className="flex items-center justify-between p-6 border-b">
+          <h2 className="text-xl font-semibold">Add Candidates</h2>
+          <button
+            onClick={onClose}
+            className="text-gray-400 hover:text-gray-600 transition-colors"
+          >
+            <X className="w-6 h-6" />
+          </button>
+        </div>
+
+        {/* Tabs */}
+        <div className="flex border-b">
+          <button
+            onClick={() => setActiveTab('manual')}
+            className={`flex-1 px-6 py-3 text-sm font-medium transition-colors ${
+              activeTab === 'manual'
+                ? 'text-purple-600 border-b-2 border-purple-600'
+                : 'text-gray-600 hover:text-gray-900'
+            }`}
+          >
+            Add a Candidate
+          </button>
+          <button
+            onClick={() => setActiveTab('bulk')}
+            className={`flex-1 px-6 py-3 text-sm font-medium transition-colors ${
+              activeTab === 'bulk'
+                ? 'text-purple-600 border-b-2 border-purple-600'
+                : 'text-gray-600 hover:text-gray-900'
+            }`}
+          >
+            Add Candidates in bulk
+          </button>
+          <button
+            onClick={() => {
+              setActiveTab('existing');
+              loadExistingCandidates(); // Refresh when switching to this tab
+            }}
+            className={`flex-1 px-6 py-3 text-sm font-medium transition-colors ${
+              activeTab === 'existing'
+                ? 'text-purple-600 border-b-2 border-purple-600'
+                : 'text-gray-600 hover:text-gray-900'
+            }`}
+          >
+            Existing Candidates ({existingCandidates.length})
+          </button>
+        </div>
+
+        {/* Content */}
+        <div className="p-6">
+          {error && (
+            <div className="mb-4 p-3 bg-red-50 border border-red-200 rounded-lg text-red-700 text-sm">
+              {error}
+            </div>
+          )}
+          {success && (
+            <div className="mb-4 p-3 bg-green-50 border border-green-200 rounded-lg text-green-700 text-sm">
+              {success}
+            </div>
+          )}
+
+          {activeTab === 'manual' ? (
+            <div className="space-y-4">
+              <div>
+                <label className="block text-sm font-medium text-gray-700 mb-2">
+                  Name
+                </label>
+                <input
+                  type="text"
+                  value={name}
+                  onChange={(e) => setName(e.target.value)}
+                  placeholder="Enter Candidate Name"
+                  className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-purple-500 focus:border-transparent"
+                />
+              </div>
+              <div>
+                <label className="block text-sm font-medium text-gray-700 mb-2">
+                  Email
+                </label>
+                <input
+                  type="email"
+                  value={email}
+                  onChange={(e) => setEmail(e.target.value)}
+                  placeholder="Enter Email"
+                  className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-purple-500 focus:border-transparent"
+                />
+              </div>
+              <div>
+                <label className="block text-sm font-medium text-gray-700 mb-2">
+                  Phone Number
+                </label>
+                <input
+                  type="tel"
+                  value={phoneNumber}
+                  onChange={(e) => setPhoneNumber(e.target.value)}
+                  placeholder="Enter Phone Number"
+                  className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-purple-500 focus:border-transparent"
+                />
+              </div>
+            </div>
+          ) : activeTab === 'existing' ? (
+            <div className="space-y-4">
+              {loadingCandidates ? (
+                <div className="text-center py-8 text-gray-500">Loading candidates...</div>
+              ) : existingCandidates.length === 0 ? (
+                <div className="text-center py-8 text-gray-500">
+                  No candidates added yet. Add candidates using the other tabs.
+                </div>
+              ) : (
+                <div className="space-y-2 max-h-96 overflow-y-auto">
+                  {existingCandidates.map((candidate) => (
+                    <div
+                      key={candidate.id}
+                      className="flex items-center justify-between p-4 border border-gray-200 rounded-lg hover:bg-gray-50 transition-colors"
+                    >
+                      <div className="flex-1">
+                        <div className="font-medium text-gray-900">{candidate.name}</div>
+                        <div className="text-sm text-gray-600">{candidate.email}</div>
+                        {candidate.phone_number && (
+                          <div className="text-xs text-gray-500 mt-1">{candidate.phone_number}</div>
+                        )}
+                      </div>
+                      <div className="flex items-center gap-3">
+                        {candidate.mail_sent ? (
+                          <div className="flex items-center gap-1 text-green-600 text-sm">
+                            <CheckCircle className="w-4 h-4" />
+                            <span>Invite Sent</span>
+                          </div>
+                        ) : (
+                          <button
+                            onClick={() => handleSendInviteToExisting(candidate.email, candidate.id)}
+                            disabled={sendingInviteTo === candidate.email}
+                            className="flex items-center gap-2 px-3 py-1.5 text-sm bg-purple-600 text-white rounded-lg hover:bg-purple-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
+                          >
+                            {sendingInviteTo === candidate.email ? (
+                              <>
+                                <span className="animate-spin"></span>
+                                Sending...
+                              </>
+                            ) : (
+                              <>
+                                <Mail className="w-4 h-4" />
+                                Send Invite
+                              </>
+                            )}
+                          </button>
+                        )}
+                      </div>
+                    </div>
+                  ))}
+                </div>
+              )}
+            </div>
+          ) : (
+            <div className="space-y-4">
+              <div
+                onDragOver={handleDragOver}
+                onDrop={handleDrop}
+                className="border-2 border-dashed border-gray-300 rounded-lg p-8 text-center hover:border-purple-400 transition-colors cursor-pointer"
+                onClick={() => fileInputRef.current?.click()}
+              >
+                <Upload className="w-12 h-12 mx-auto text-gray-400 mb-4" />
+                <p className="text-gray-700 mb-2">Click to upload or Drag & Drop your file here</p>
+                <p className="text-sm text-gray-500 mb-2">Supported formats: .csv, .xlsx</p>
+                <p className="text-xs text-gray-400">Each row should include: Name, Email, and Phone Number.</p>
+                <input
+                  ref={fileInputRef}
+                  type="file"
+                  accept=".csv,.xlsx"
+                  onChange={handleFileSelect}
+                  className="hidden"
+                />
+              </div>
+              {uploadFile && (
+                <div className="p-3 bg-gray-50 rounded-lg">
+                  <p className="text-sm text-gray-700">
+                    Selected: <span className="font-medium">{uploadFile.name}</span>
+                  </p>
+                </div>
+              )}
+              <div className="flex items-center gap-2 text-sm text-purple-600 hover:text-purple-700">
+                <Download className="w-4 h-4" />
+                <button
+                  onClick={downloadSampleCSV}
+                  className="underline"
+                >
+                  Download sample file (.csv)
+                </button>
+              </div>
+            </div>
+          )}
+        </div>
+
+        {/* Footer */}
+        {activeTab !== 'existing' && (
+          <div className="flex items-center justify-end gap-3 p-6 border-t bg-gray-50">
+            <button
+              onClick={onClose}
+              className="px-4 py-2 text-purple-600 border border-purple-600 rounded-lg hover:bg-purple-50 transition-colors"
+            >
+              Cancel
+            </button>
+            <button
+              onClick={() => handleAddCandidate(false)}
+              disabled={loading}
+              className="px-4 py-2 bg-purple-600 text-white rounded-lg hover:bg-purple-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
+            >
+              {loading ? 'Adding...' : 'Add Candidate'}
+            </button>
+            <button
+              onClick={() => handleAddCandidate(true)}
+              disabled={loading}
+              className="px-4 py-2 bg-purple-600 text-white rounded-lg hover:bg-purple-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed flex items-center gap-2"
+            >
+              {loading ? (
+                <>
+                  <span className="animate-spin"></span>
+                  Sending...
+                </>
+              ) : (
+                <>
+                  <UserPlus className="w-4 h-4" />
+                  Send Invite
+                </>
+              )}
+            </button>
+          </div>
+        )}
+        {activeTab === 'existing' && (
+          <div className="flex items-center justify-end gap-3 p-6 border-t bg-gray-50">
+            <button
+              onClick={onClose}
+              className="px-4 py-2 text-purple-600 border border-purple-600 rounded-lg hover:bg-purple-50 transition-colors"
+            >
+              Close
+            </button>
+          </div>
+        )}
+      </div>
+    </div>
+  );
+}
+
diff --git a/frontend/src/components/CandidateAnalytics.tsx b/frontend/src/components/CandidateAnalytics.tsx
index 5efd12a..3b2c3e3 100644
--- a/frontend/src/components/CandidateAnalytics.tsx
+++ b/frontend/src/components/CandidateAnalytics.tsx
@@ -1,4 +1,5 @@
 import { useEffect, useState } from 'react';
+import { getApiHeaders } from '../utils/api';
 
 interface Props { apiBaseUrl: string; interviewId: string; responseId: string }
 
@@ -11,11 +12,10 @@ export default function CandidateAnalytics({ apiBaseUrl, interviewId, responseId
     const abortController = new AbortController();
     const loadData = async () => {
       try {
+        // Load response data first to check if video already exists
         const res = await fetch(`${apiBaseUrl}/api/interview/get-response?response_id=${encodeURIComponent(responseId)}`, {
           method: 'GET',
-          headers: {
-            'Content-Type': 'application/json',
-          },
+          headers: getApiHeaders(false),
           signal: abortController.signal
         });
         if (abortController.signal.aborted) return;
@@ -55,9 +55,29 @@ export default function CandidateAnalytics({ apiBaseUrl, interviewId, responseId
       {/* Candidate Info */}
       {data?.candidate && (
         <div className="mb-6 flex items-center gap-4">
-          <div className="w-12 h-12 rounded-full bg-purple-600 flex items-center justify-center text-white font-semibold text-lg">
-            {(data.candidate.name || 'C')[0].toUpperCase()}
-          </div>
+          {data.candidate.image_url ? (
+            <img 
+              src={`${apiBaseUrl}/api/media/files/${data.candidate.image_url}`}
+              alt={data.candidate.name || 'Candidate'}
+              className="w-12 h-12 rounded-full object-cover"
+              onError={(e) => {
+                // Fallback to initial if image fails to load
+                const target = e.target as HTMLImageElement;
+                target.style.display = 'none';
+                const parent = target.parentElement;
+                if (parent) {
+                  const fallback = document.createElement('div');
+                  fallback.className = 'w-12 h-12 rounded-full bg-purple-600 flex items-center justify-center text-white font-semibold text-lg';
+                  fallback.textContent = (data.candidate.name || 'C')[0].toUpperCase();
+                  parent.appendChild(fallback);
+                }
+              }}
+            />
+          ) : (
+            <div className="w-12 h-12 rounded-full bg-purple-600 flex items-center justify-center text-white font-semibold text-lg">
+              {(data.candidate.name || 'C')[0].toUpperCase()}
+            </div>
+          )}
           <div>
             <div className="font-semibold">{data.candidate.name || 'Anonymous'}</div>
             <div className="text-sm text-gray-600">{data.candidate.email || ''}</div>
@@ -65,6 +85,63 @@ export default function CandidateAnalytics({ apiBaseUrl, interviewId, responseId
         </div>
       )}
 
+      {/* Video Preview Section */}
+      {data?.recording?.video_url && (
+        <div className="mb-6 border rounded-lg p-6 bg-white">
+          <h2 className="text-xl font-semibold mb-4">Interview Recording</h2>
+          <div className="relative w-full max-w-4xl mx-auto">
+            <video 
+              controls 
+              className="w-full rounded-lg"
+              src={(() => {
+                const url = data.recording.video_url || '';
+                if (!url) return '';
+                
+                // If it's a full URL, extract the path and use current apiBaseUrl
+                if (url.startsWith('http://') || url.startsWith('https://')) {
+                  try {
+                    const urlObj = new URL(url);
+                    const path = urlObj.pathname;
+                    // Normalize path: remove leading double slashes
+                    const normalized = path.replace(/^\/+/, '/');
+                    return `${apiBaseUrl}${normalized}`;
+                  } catch (e) {
+                    // If URL parsing fails, try to extract path manually
+                    const match = url.match(/\/api\/media\/files\/videos\/[^\/]+\.mp4/);
+                    if (match) {
+                      const normalized = match[0].replace(/^\/+/, '/');
+                      return `${apiBaseUrl}${normalized}`;
+                    }
+                    return url; // Fallback to original URL
+                  }
+                }
+                
+                // Normalize relative URLs: remove leading double slashes
+                const normalized = url.replace(/^\/+/, '/');
+                return `${apiBaseUrl}${normalized}`;
+              })()}
+              onError={(e) => {
+                console.error('[VIDEO] Failed to load video:', data.recording.video_url, e);
+                const video = e.target as HTMLVideoElement;
+                video.style.display = 'none';
+                const parent = video.parentElement;
+                if (parent) {
+                  const errorMsg = document.createElement('div');
+                  errorMsg.className = 'text-red-600 p-4 text-center';
+                  errorMsg.textContent = `Video not available. URL: ${data.recording.video_url}`;
+                  parent.appendChild(errorMsg);
+                }
+              }}
+            >
+              Your browser does not support the video tag.
+            </video>
+          </div>
+          {data.recording.duration && (
+            <p className="text-sm text-gray-600 mt-2">Duration: {data.recording.duration}</p>
+          )}
+        </div>
+      )}
+
       {/* General Summary Section */}
       <div className="mb-6 border rounded-lg p-6 bg-white">
         <h2 className="text-xl font-semibold mb-4">General Summary</h2>
diff --git a/frontend/src/components/CandidateStart.tsx b/frontend/src/components/CandidateStart.tsx
index 6139170..e7e5cc8 100644
--- a/frontend/src/components/CandidateStart.tsx
+++ b/frontend/src/components/CandidateStart.tsx
@@ -1,6 +1,7 @@
-import { useState, useEffect } from 'react';
+import { useState, useEffect, useRef } from 'react';
 import InterviewSession from './InterviewSession';
 import { getApiHeaders } from '../utils/api';
+import { uploadCandidateImage } from '../utils/api';
 
 interface Props { apiBaseUrl: string; interviewId: string }
 
@@ -13,6 +14,21 @@ export default function CandidateStart({ apiBaseUrl, interviewId }: Props) {
   const [statusError, setStatusError] = useState('');
   const [accessError, setAccessError] = useState('');
   const [actualInterviewId, setActualInterviewId] = useState<string>('');
+  const [responseId, setResponseId] = useState<string | null>(null);
+  
+  // Camera and image capture states
+  const [cameraStream, setCameraStream] = useState<MediaStream | null>(null);
+  const [capturedBlob, setCapturedBlob] = useState<Blob | null>(null);
+  const [uploadingPhoto, setUploadingPhoto] = useState(false);
+  const [photoUploaded, setPhotoUploaded] = useState(false);
+  const [cameraReady, setCameraReady] = useState(false);
+  
+  // Screen recording permission
+  const [screenPermissionGranted, setScreenPermissionGranted] = useState(false);
+  const [screenShareStream, setScreenShareStream] = useState<MediaStream | null>(null);
+  
+  const videoRef = useRef<HTMLVideoElement | null>(null);
+  const canvasRef = useRef<HTMLCanvasElement | null>(null);
 
   useEffect(() => {
     const checkInterviewStatus = async () => {
@@ -46,11 +62,193 @@ export default function CandidateStart({ apiBaseUrl, interviewId }: Props) {
     checkInterviewStatus();
   }, [apiBaseUrl, interviewId]);
 
+  // Cleanup camera stream and screen share stream on unmount
+  useEffect(() => {
+    return () => {
+      if (cameraStream) {
+        cameraStream.getTracks().forEach(track => track.stop());
+      }
+      // Only cleanup screen share if component is unmounting and interview hasn't started
+      if (screenShareStream && !started) {
+        screenShareStream.getTracks().forEach(track => track.stop());
+      }
+    };
+  }, [cameraStream, screenShareStream, started]);
+
+  // Update video element when cameraStream changes
+  useEffect(() => {
+    if (cameraStream && videoRef.current) {
+      const video = videoRef.current;
+      if (video.srcObject !== cameraStream) {
+        video.srcObject = cameraStream;
+        video.playsInline = true;
+        video.muted = true;
+        video.autoplay = true;
+        
+        // Wait for video metadata to determine if camera is ready
+        const onLoadedMetadata = () => {
+          if (video.videoWidth > 0 && video.videoHeight > 0) {
+            setCameraReady(true);
+          }
+        };
+        
+        const onCanPlay = () => {
+          if (video.videoWidth > 0 && video.videoHeight > 0) {
+            setCameraReady(true);
+          }
+        };
+        
+        video.addEventListener('loadedmetadata', onLoadedMetadata, { once: true });
+        video.addEventListener('canplay', onCanPlay, { once: true });
+        
+        // Check if already ready
+        if (video.readyState >= 2 && video.videoWidth > 0 && video.videoHeight > 0) {
+          setCameraReady(true);
+        }
+        
+        // Play the video
+        video.play().catch(err => {
+          console.warn('Video play failed:', err);
+        });
+      }
+    } else if (!cameraStream && videoRef.current) {
+      // Clear video element when stream is removed
+      videoRef.current.srcObject = null;
+      setCameraReady(false);
+    }
+  }, [cameraStream]);
+
+  const startCamera = async () => {
+    try {
+      const stream = await navigator.mediaDevices.getUserMedia({ 
+        video: { 
+          facingMode: 'user',
+          width: { ideal: 1280 },
+          height: { ideal: 720 }
+        }, 
+        audio: false 
+      });
+      
+      // Set the stream state - useEffect will handle attaching it to video element
+      setCameraStream(stream);
+    } catch (e) {
+      setStatusError('Camera permission denied or unavailable. Please enable camera access.');
+      console.error('Camera error:', e);
+    }
+  };
+
+  const capturePhoto = () => {
+    if (!videoRef.current || !cameraReady) {
+      setAccessError('Camera not ready yet. Please wait a moment and try again.');
+      return;
+    }
+
+    const video = videoRef.current;
+    const canvas = canvasRef.current || document.createElement('canvas');
+    canvasRef.current = canvas;
+
+    const w = video.videoWidth || 640;
+    const h = video.videoHeight || 480;
+
+    if (w === 0 || h === 0) {
+      requestAnimationFrame(() => capturePhoto());
+      return;
+    }
+
+    canvas.width = w;
+    canvas.height = h;
+    const ctx = canvas.getContext('2d');
+    if (!ctx) return;
+
+    ctx.drawImage(video, 0, 0, w, h);
+    canvas.toBlob((blob) => {
+      if (blob) {
+        setCapturedBlob(blob);
+      }
+    }, 'image/jpeg', 0.9);
+  };
+
+  const uploadPhoto = async () => {
+    if (!capturedBlob) {
+      setAccessError('Please capture a photo first.');
+      return;
+    }
+
+    if (!responseId) {
+      // Photo will be uploaded when interview starts
+      setAccessError('Photo will be uploaded when you start the interview.');
+      return;
+    }
+
+    setUploadingPhoto(true);
+    try {
+      await uploadCandidateImage(apiBaseUrl, capturedBlob, responseId, 'candidate.jpg');
+      setPhotoUploaded(true);
+      if (cameraStream) {
+        cameraStream.getTracks().forEach(track => track.stop());
+        setCameraStream(null);
+      }
+    } catch (e) {
+      setAccessError('Failed to upload photo. Please try again.');
+      console.error('Upload error:', e);
+    } finally {
+      setUploadingPhoto(false);
+    }
+  };
+
+  const requestScreenPermission = async () => {
+    try {
+      const displayStream = await (navigator.mediaDevices as any).getDisplayMedia({ 
+        video: { displaySurface: 'monitor' },
+        audio: true 
+      });
+      
+      // Validate that full screen is being shared, not just a window
+      const videoTrack = displayStream.getVideoTracks()[0];
+      const settings = videoTrack.getSettings();
+      const displaySurface = (settings as any).displaySurface;
+      
+      if (displaySurface !== 'monitor') {
+        // Reject window/tab-only sharing
+        displayStream.getTracks().forEach((track: MediaStreamTrack) => track.stop());
+        setAccessError('Full screen sharing is required. Please select "Entire Screen" instead of a single window or tab.');
+        return;
+      }
+      
+      // Validate that audio is enabled during screen sharing
+      const audioTracks = displayStream.getAudioTracks();
+      if (audioTracks.length === 0) {
+        // Audio was not enabled during screen sharing
+        displayStream.getTracks().forEach((track: MediaStreamTrack) => track.stop());
+        setAccessError('Please enable audio while sharing your screen. When sharing, make sure to check the "Share audio" or "Share system audio" option in the browser dialog.');
+        return;
+      }
+      
+      // Keep the stream alive - don't stop it! We'll use it in the interview session
+      setScreenShareStream(displayStream);
+      setScreenPermissionGranted(true);
+    } catch (e) {
+      setAccessError('Screen recording permission denied. Screen recording is required to proceed.');
+      console.error('Screen permission error:', e);
+    }
+  };
+
   const handleStart = async () => {
     if (!name.trim() || !email.trim()) {
       setAccessError('Please provide both name and email');
       return;
     }
+
+    // Check if photo is captured and screen permission is granted
+    if (!capturedBlob) {
+      setAccessError('Please capture your photo before starting the interview.');
+      return;
+    }
+
+    if (!screenPermissionGranted) {
+      setAccessError('Please grant screen recording permission before starting the interview.');
+      return;
+    }
     
     setAccessError('');
     setLoadingStatus(true);
@@ -75,6 +273,21 @@ export default function CandidateStart({ apiBaseUrl, interviewId }: Props) {
         setLoadingStatus(false);
         return;
       }
+
+      // Store response_id and upload photo
+      if (data.response_id) {
+        setResponseId(data.response_id);
+        // Upload photo now that we have response_id
+        if (capturedBlob) {
+          try {
+            await uploadCandidateImage(apiBaseUrl, capturedBlob, data.response_id, 'candidate.jpg');
+            setPhotoUploaded(true);
+          } catch (e) {
+            console.error('Failed to upload photo after starting:', e);
+            // Don't block interview start if photo upload fails
+          }
+        }
+      }
       
       setStarted(true);
     } catch (err) {
@@ -90,6 +303,8 @@ export default function CandidateStart({ apiBaseUrl, interviewId }: Props) {
         interviewId={actualInterviewId || interviewId}
         candidateName={name || 'Anonymous'}
         candidateEmail={email || 'anonymous@example.com'}
+        screenPermissionGranted={screenPermissionGranted}
+        existingScreenStream={screenShareStream}
       />
     );
   }
@@ -128,26 +343,186 @@ export default function CandidateStart({ apiBaseUrl, interviewId }: Props) {
       <div className="bg-white rounded-2xl shadow-xl max-w-md w-full p-8">
         <h1 className="text-2xl font-bold mb-1">Start Interview</h1>
         <p className="text-gray-600 mb-6">Interview ID: {interviewId}</p>
+        
+        {/* Pre-Interview Rules & Instructions */}
+        <div className="mb-6 p-4 bg-blue-50 border border-blue-200 rounded-lg text-sm">
+          <h2 className="font-bold text-blue-900 mb-3"> Pre-Interview Requirements & Instructions</h2>
+          <div className="space-y-2 text-blue-800">
+            <div>
+              <span className="font-semibold"> Identity Verification (Mandatory):</span>
+              <p className="ml-4">Your webcam will capture your photo for identity confirmation.</p>
+            </div>
+            <div>
+              <span className="font-semibold"> Screen Sharing (Mandatory):</span>
+              <p className="ml-4">You must share your entire screen  single-window sharing is not allowed. If full screen is not shared, the interview will not start.</p>
+            </div>
+            <div>
+              <span className="font-semibold"> Camera & Audio Requirements:</span>
+              <ul className="ml-4 list-disc list-inside">
+                <li>Keep your face clearly visible and stay centered in the frame</li>
+                <li>Enable microphone and speaker audio</li>
+                <li>Do not mute your system audio  the AI interviewer voice must be audible</li>
+              </ul>
+            </div>
+            <div>
+              <span className="font-semibold"> Activity Monitoring:</span>
+              <p className="ml-4">Do not switch tabs/windows during the interview. Any screen switching or suspicious activity will trigger a cheating alert and may end the interview.</p>
+            </div>
+            <div>
+              <span className="font-semibold"> Interview Environment Rules:</span>
+              <ul className="ml-4 list-disc list-inside">
+                <li>Ensure stable internet and good lighting</li>
+                <li>Sit in a quiet place without interruptions</li>
+                <li>Maintain eye contact and respond naturally</li>
+              </ul>
+            </div>
+            <p className="mt-3 font-semibold text-blue-900">Your cooperation helps us ensure a fair and secure interview experience.</p>
+            <p className="mt-2 text-xs text-blue-700">Click "Start Interview" only after agreeing to these conditions.</p>
+          </div>
+        </div>
+
         <div className="space-y-4">
           <div>
             <label className="block text-sm font-semibold text-gray-700 mb-2">Name</label>
-            <input value={name} onChange={e=>setName(e.target.value)} className="w-full px-4 py-3 border border-gray-300 rounded-lg" placeholder="Your name" />
+            <input 
+              value={name} 
+              onChange={e => setName(e.target.value)} 
+              className="w-full px-4 py-3 border border-gray-300 rounded-lg" 
+              placeholder="Your name" 
+            />
           </div>
           <div>
             <label className="block text-sm font-semibold text-gray-700 mb-2">Email</label>
-            <input value={email} onChange={e=>setEmail(e.target.value)} className="w-full px-4 py-3 border border-gray-300 rounded-lg" placeholder="you@example.com" />
+            <input 
+              value={email} 
+              onChange={e => setEmail(e.target.value)} 
+              className="w-full px-4 py-3 border border-gray-300 rounded-lg" 
+              placeholder="you@example.com" 
+            />
+          </div>
+
+          {/* Camera Photo Capture Section */}
+          <div className="border rounded-lg p-4 bg-gray-50">
+            <div className="flex items-center justify-between mb-3">
+              <span className="font-semibold text-gray-700">Camera Photo *</span>
+              {photoUploaded ? (
+                <span className="text-green-600 text-sm font-medium"> Uploaded</span>
+              ) : null}
+            </div>
+            {!cameraStream && !capturedBlob && !photoUploaded && (
+              <button 
+                onClick={startCamera} 
+                className="w-full bg-gray-200 hover:bg-gray-300 text-gray-800 py-2 rounded font-medium transition"
+              >
+                Enable Camera
+              </button>
+            )}
+            {cameraStream && !capturedBlob && (
+              <div className="space-y-2">
+                <video 
+                  ref={videoRef} 
+                  className="w-full rounded border border-gray-300 bg-gray-100" 
+                  autoPlay 
+                  playsInline 
+                  muted
+                  style={{ minHeight: '200px', objectFit: 'cover' }}
+                />
+                <div className="flex gap-2">
+                  <button 
+                    onClick={capturePhoto} 
+                    disabled={!cameraReady}
+                    className="flex-1 bg-blue-600 hover:bg-blue-700 text-white py-2 rounded font-medium transition disabled:bg-gray-300"
+                  >
+                    Capture
+                  </button>
+                  <button 
+                    onClick={() => {
+                      cameraStream.getTracks().forEach(t => t.stop());
+                      setCameraStream(null);
+                      setCameraReady(false);
+                    }} 
+                    className="px-4 bg-gray-200 hover:bg-gray-300 text-gray-800 rounded font-medium transition"
+                  >
+                    Close
+                  </button>
+                </div>
+              </div>
+            )}
+            {capturedBlob && !photoUploaded && (
+              <div className="space-y-2">
+                <img 
+                  src={URL.createObjectURL(capturedBlob)} 
+                  alt="Preview" 
+                  className="w-full rounded border border-gray-300" 
+                />
+                <div className="flex gap-2">
+                  <button 
+                    onClick={() => {
+                      setCapturedBlob(null);
+                      URL.revokeObjectURL(URL.createObjectURL(capturedBlob));
+                    }} 
+                    className="flex-1 bg-gray-200 hover:bg-gray-300 text-gray-800 py-2 rounded font-medium transition"
+                  >
+                    Retake
+                  </button>
+                  <button 
+                    disabled={uploadingPhoto || !responseId} 
+                    onClick={uploadPhoto} 
+                    className="flex-1 bg-orange-600 text-white py-2 rounded hover:bg-orange-700 disabled:bg-gray-300 font-medium transition"
+                  >
+                    {uploadingPhoto ? 'Uploading...' : 'Upload Photo'}
+                  </button>
+                </div>
+                {!responseId && (
+                  <p className="text-xs text-gray-500 mt-1">
+                    Photo will be uploaded when you start the interview
+                  </p>
+                )}
+              </div>
+            )}
           </div>
+
+          {/* Screen Recording Permission Section */}
+          <div className="border rounded-lg p-4 bg-gray-50">
+            <div className="flex items-center justify-between mb-3">
+              <span className="font-semibold text-gray-700">Screen Recording Permission *</span>
+              {screenPermissionGranted ? (
+                <span className="text-green-600 text-sm font-medium"> Granted</span>
+              ) : null}
+            </div>
+            {!screenPermissionGranted && (
+              <button 
+                onClick={requestScreenPermission} 
+                className="w-full bg-gray-200 hover:bg-gray-300 text-gray-800 py-2 rounded font-medium transition"
+              >
+                Grant Screen Access
+              </button>
+            )}
+            {screenPermissionGranted && (
+              <div className="text-sm text-gray-600">
+                Screen access granted. Recording will start automatically when the interview begins.
+              </div>
+            )}
+          </div>
+
           {accessError && (
             <div className="bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded-lg text-sm">
               {accessError}
             </div>
           )}
+          
           <button 
             onClick={handleStart} 
-            disabled={!name.trim() || !email.trim() || loadingStatus}
-            className="w-full bg-orange-600 text-white py-3 rounded-lg font-semibold hover:bg-orange-700 disabled:bg-gray-300 disabled:cursor-not-allowed"
+            disabled={
+              !name.trim() || 
+              !email.trim() || 
+              loadingStatus || 
+              !capturedBlob || 
+              !screenPermissionGranted
+            }
+            className="w-full bg-orange-600 text-white py-3 rounded-lg font-semibold hover:bg-orange-700 disabled:bg-gray-300 disabled:cursor-not-allowed transition"
           >
-            {loadingStatus ? 'Starting...' : 'Start'}
+            {loadingStatus ? 'Starting...' : 'Start Interview'}
           </button>
         </div>
       </div>
diff --git a/frontend/src/components/Candidates.tsx b/frontend/src/components/Candidates.tsx
new file mode 100644
index 0000000..322ed86
--- /dev/null
+++ b/frontend/src/components/Candidates.tsx
@@ -0,0 +1,166 @@
+import React, { useEffect, useMemo, useState } from 'react';
+import { addCandidate, bulkAddCandidatesCsv, listCandidates, markCandidateMailSent } from '../utils/api';
+
+type CandidateItem = {
+  id: string;
+  interview_id: string;
+  name: string;
+  email: string;
+  phone_number?: string | null;
+  mail_sent: boolean;
+  response_id?: string | null;
+  response_given: boolean;
+};
+
+interface Props {
+  apiBaseUrl: string;
+  interviewId?: string;
+}
+
+const Badge: React.FC<{ label: string; color: 'green' | 'red' | 'yellow' }> = ({ label, color }) => {
+  const classes = {
+    green: 'bg-green-100 text-green-800',
+    red: 'bg-red-100 text-red-800',
+    yellow: 'bg-yellow-100 text-yellow-800',
+  }[color];
+  return <span className={`px-2 py-1 rounded text-xs font-medium ${classes}`}>{label}</span>;
+};
+
+export const Candidates: React.FC<Props> = ({ apiBaseUrl, interviewId }) => {
+  const effectiveInterviewId = useMemo(() => interviewId || '', [interviewId]);
+
+  const [items, setItems] = useState<CandidateItem[]>([]);
+  const [loading, setLoading] = useState(false);
+  const [error, setError] = useState<string | null>(null);
+  const [name, setName] = useState('');
+  const [email, setEmail] = useState('');
+  const [phone, setPhone] = useState('');
+  const [csvFile, setCsvFile] = useState<File | null>(null);
+
+  const load = async () => {
+    if (!effectiveInterviewId) return;
+    setLoading(true);
+    setError(null);
+    try {
+      const res = await listCandidates(apiBaseUrl, effectiveInterviewId);
+      setItems(res.candidates || []);
+    } catch (e: any) {
+      setError(e.message || 'Failed to load candidates');
+    } finally {
+      setLoading(false);
+    }
+  };
+
+  useEffect(() => {
+    load();
+  }, [effectiveInterviewId]);
+
+  const onAdd = async (e: React.FormEvent) => {
+    e.preventDefault();
+    if (!effectiveInterviewId) return;
+    try {
+      await addCandidate(apiBaseUrl, { interview_id: effectiveInterviewId, name, email, phone_number: phone || undefined });
+      setName('');
+      setEmail('');
+      setPhone('');
+      await load();
+    } catch (e: any) {
+      setError(e.message || 'Failed to add candidate');
+    }
+  };
+
+  const onImportCsv = async () => {
+    if (!effectiveInterviewId || !csvFile) return;
+    try {
+      await bulkAddCandidatesCsv(apiBaseUrl, effectiveInterviewId, csvFile);
+      setCsvFile(null);
+      (document.getElementById('csv-input') as HTMLInputElement | null)?.value && ((document.getElementById('csv-input') as HTMLInputElement).value = '');
+      await load();
+    } catch (e: any) {
+      setError(e.message || 'Failed to import CSV');
+    }
+  };
+
+  const toggleMailSent = async (candidateId: string, current: boolean) => {
+    try {
+      await markCandidateMailSent(apiBaseUrl, candidateId, !current);
+      await load();
+    } catch (e: any) {
+      setError(e.message || 'Failed to update mail status');
+    }
+  };
+
+  return (
+    <div className="max-w-6xl mx-auto p-4 space-y-6">
+      <h2 className="text-2xl font-semibold">Candidates</h2>
+      {error && <div className="text-red-600 text-sm">{error}</div>}
+
+      <form onSubmit={onAdd} className="grid grid-cols-1 md:grid-cols-5 gap-3 items-end">
+        <div>
+          <label className="block text-sm font-medium mb-1">Name</label>
+          <input value={name} onChange={e => setName(e.target.value)} className="w-full border rounded px-3 py-2" required />
+        </div>
+        <div>
+          <label className="block text-sm font-medium mb-1">Email</label>
+          <input type="email" value={email} onChange={e => setEmail(e.target.value)} className="w-full border rounded px-3 py-2" required />
+        </div>
+        <div>
+          <label className="block text-sm font-medium mb-1">Phone</label>
+          <input value={phone} onChange={e => setPhone(e.target.value)} className="w-full border rounded px-3 py-2" />
+        </div>
+        <div className="md:col-span-2 flex gap-3 items-end">
+          <button type="submit" className="bg-blue-600 text-white px-4 py-2 rounded">Add Candidate</button>
+        </div>
+      </form>
+
+      <div className="flex items-center gap-3">
+        <input id="csv-input" type="file" accept=".csv" onChange={e => setCsvFile(e.target.files?.[0] || null)} />
+        <button onClick={onImportCsv} className="bg-gray-700 text-white px-3 py-2 rounded" disabled={!csvFile}>Import CSV</button>
+        <div className="text-xs text-gray-600">CSV headers: name,email,phone_number</div>
+      </div>
+
+      <div className="overflow-auto">
+        <table className="min-w-full border">
+          <thead className="bg-gray-50">
+            <tr>
+              <th className="text-left px-3 py-2 border">Name</th>
+              <th className="text-left px-3 py-2 border">Email</th>
+              <th className="text-left px-3 py-2 border">Phone</th>
+              <th className="text-left px-3 py-2 border">Mail Sent</th>
+              <th className="text-left px-3 py-2 border">Response</th>
+              <th className="text-left px-3 py-2 border">Actions</th>
+            </tr>
+          </thead>
+          <tbody>
+            {items.map(c => (
+              <tr key={c.id} className="border-t">
+                <td className="px-3 py-2">{c.name}</td>
+                <td className="px-3 py-2">{c.email}</td>
+                <td className="px-3 py-2">{c.phone_number || '-'}</td>
+                <td className="px-3 py-2">
+                  {c.mail_sent ? <Badge label="Sent" color="green" /> : <Badge label="Not Sent" color="yellow" />}
+                </td>
+                <td className="px-3 py-2">
+                  {c.response_given ? <Badge label="Received" color="green" /> : <Badge label="Pending" color="red" />}
+                </td>
+                <td className="px-3 py-2">
+                  <button onClick={() => toggleMailSent(c.id, c.mail_sent)} className="text-sm bg-indigo-600 text-white px-3 py-1 rounded">
+                    Mark as {c.mail_sent ? 'Not Sent' : 'Sent'}
+                  </button>
+                </td>
+              </tr>
+            ))}
+            {items.length === 0 && !loading && (
+              <tr>
+                <td colSpan={6} className="text-center text-sm text-gray-500 py-6">No candidates yet</td>
+              </tr>
+            )}
+          </tbody>
+        </table>
+      </div>
+    </div>
+  );
+};
+
+export default Candidates;
+ 
\ No newline at end of file
diff --git a/frontend/src/components/CreateInterview.tsx b/frontend/src/components/CreateInterview.tsx
index 1a78a88..6da78ed 100644
--- a/frontend/src/components/CreateInterview.tsx
+++ b/frontend/src/components/CreateInterview.tsx
@@ -2,10 +2,12 @@ import { useState, useEffect } from 'react';
 import { getApiHeaders } from '../utils/api';
 import { FileText, Info } from 'lucide-react';
 import EditQuestionsModal from './EditQuestionsModal';
+import AddCandidateDialog from './AddCandidateDialog';
 
 interface CreateInterviewProps {
   onInterviewCreated?: (interviewId: string, interviewData: any) => void;
   apiBaseUrl: string;
+  interviewId?: string; // For edit mode
 }
 
 interface Interviewer {
@@ -15,10 +17,11 @@ interface Interviewer {
 
 }
 
-export default function CreateInterview({ apiBaseUrl }: CreateInterviewProps) {
+export default function CreateInterview({ apiBaseUrl, interviewId: editInterviewId }: CreateInterviewProps) {
   const [formData, setFormData] = useState({
     name: '',
-    objective: '',
+    job_description: '',
+    department: '',
     question_count: 3,
     difficulty_level: 'medium' as 'low' | 'medium' | 'high',
     interviewer_id: '',
@@ -29,6 +32,7 @@ export default function CreateInterview({ apiBaseUrl }: CreateInterviewProps) {
   const [error, setError] = useState('');
   const [showModal, setShowModal] = useState(false);
   const [createdInterviewId, setCreatedInterviewId] = useState<string>('');
+  const [showAddCandidateDialog, setShowAddCandidateDialog] = useState(false);
   const [interviewers, setInterviewers] = useState<Interviewer[]>([]);
   const [loadingInterviewers, setLoadingInterviewers] = useState(true);
 
@@ -39,7 +43,41 @@ export default function CreateInterview({ apiBaseUrl }: CreateInterviewProps) {
 
   useEffect(() => {
     loadInterviewers();
-  }, [apiBaseUrl]);
+    if (editInterviewId) {
+      loadInterviewForEdit();
+    }
+  }, [apiBaseUrl, editInterviewId]);
+  
+  const loadInterviewForEdit = async () => {
+    try {
+      const response = await fetch(`${apiBaseUrl}/api/interview/list-interviews`, {
+        method: 'GET',
+        headers: getApiHeaders(false),
+      });
+      if (response.ok) {
+        const data = await response.json();
+        const interview = data.interviews?.find((i: any) => i.id === editInterviewId);
+        if (interview) {
+          setFormData({
+            name: interview.name || '',
+            job_description: interview.job_description || '',
+            department: interview.department || '',
+            question_count: interview.question_count || 3,
+            difficulty_level: interview.context?.difficulty_level || 'medium',
+            interviewer_id: interview.interviewer_id || '',
+            duration_minutes: interview.time_duration ? parseInt(interview.time_duration) : 10,
+          });
+          setAutoOrManual(interview.auto_question_generate ? 'auto' : 'manual');
+          setAutoMode(interview.mode === 'dynamic' ? 'dynamic' : 'predefined');
+          if (editInterviewId) {
+            setCreatedInterviewId(editInterviewId);
+          }
+        }
+      }
+    } catch (err) {
+      console.error('Failed to load interview for edit:', err);
+    }
+  };
 
   const loadInterviewers = async () => {
     try {
@@ -76,7 +114,10 @@ export default function CreateInterview({ apiBaseUrl }: CreateInterviewProps) {
     try {
       const fd = new FormData();
       fd.append('name', formData.name);
-      fd.append('objective', formData.objective);
+      fd.append('job_description', formData.job_description);
+      if (formData.department) {
+        fd.append('department', formData.department);
+      }
       fd.append('question_count', String(formData.question_count));
       fd.append('difficulty_level', formData.difficulty_level);
       
@@ -90,24 +131,42 @@ export default function CreateInterview({ apiBaseUrl }: CreateInterviewProps) {
         fd.append('interviewer_id', formData.interviewer_id);
       }
       
-      // Create interview without generating questions yet
-      fd.append('mode', autoOrManual === 'auto' ? autoMode : 'predefined');
-      fd.append('auto_question_generate', String(autoOrManual === 'auto'));
-      fd.append('manual_questions', '[]'); // Will be set in modal
-      
-      if (jdFile) {
-        fd.append('jd_file', jdFile);
-      }
-      
-      const response = await fetch(`${apiBaseUrl}/api/interview/create-interview`, {
+      // Create or update interview
+      if (editInterviewId) {
+        // Edit mode - update existing interview
+        fd.append('interview_id', editInterviewId);
+        fd.append('mode', autoOrManual === 'auto' ? autoMode : 'predefined');
+        fd.append('auto_question_generate', String(autoOrManual === 'auto'));
+        
+        const response = await fetch(`${apiBaseUrl}/api/interview/update-interview`, {
           method: 'POST',
-          headers: getApiHeaders(false), // FormData sets Content-Type automatically
+          headers: getApiHeaders(false),
           body: fd,
         });
-      if (!response.ok) throw new Error('Failed to create interview');
-      const data = await response.json();
-      setCreatedInterviewId(data.id);
-      setShowModal(true); // Show modal to edit questions
+        if (!response.ok) throw new Error('Failed to update interview');
+        // Show modal to review/edit questions after updating
+        setCreatedInterviewId(editInterviewId);
+        setShowModal(true);
+      } else {
+        // Create mode
+        fd.append('mode', autoOrManual === 'auto' ? autoMode : 'predefined');
+        fd.append('auto_question_generate', String(autoOrManual === 'auto'));
+        fd.append('manual_questions', '[]'); // Will be set in modal
+        
+        if (jdFile) {
+          fd.append('jd_file', jdFile);
+        }
+        
+        const response = await fetch(`${apiBaseUrl}/api/interview/create-interview`, {
+          method: 'POST',
+          headers: getApiHeaders(false),
+          body: fd,
+        });
+        if (!response.ok) throw new Error('Failed to create interview');
+        const data = await response.json();
+        setCreatedInterviewId(data.id);
+        setShowModal(true); // Show modal to edit questions
+      }
     } catch (err) {
       setError(err instanceof Error ? err.message : 'An error occurred');
     } finally {
@@ -116,7 +175,21 @@ export default function CreateInterview({ apiBaseUrl }: CreateInterviewProps) {
   };
 
   const handleModalSave = () => {
-    // Redirect to interviews list after saving
+    // Close the questions modal
+    setShowModal(false);
+    if (editInterviewId) {
+      // If editing, redirect to interview detail page
+      window.history.pushState({}, '', `/interviews/${editInterviewId}`);
+      window.dispatchEvent(new PopStateEvent('popstate'));
+    } else {
+      // If creating, show add candidate dialog
+      setShowAddCandidateDialog(true);
+    }
+  };
+  
+  const handleAddCandidateDialogClose = () => {
+    setShowAddCandidateDialog(false);
+    // Redirect to interviews list after closing
     window.history.pushState({}, '', '/');
     window.dispatchEvent(new PopStateEvent('popstate'));
   };
@@ -134,8 +207,8 @@ export default function CreateInterview({ apiBaseUrl }: CreateInterviewProps) {
             <FileText className="w-8 h-8 text-white" />
           </div>
           <div>
-            <h1 className="text-3xl font-bold text-gray-900">Create an Interview</h1>
-            <p className="text-gray-600">Set up your interview session</p>
+            <h1 className="text-3xl font-bold text-gray-900">{editInterviewId ? 'Edit Interview' : 'Create an Interview'}</h1>
+            <p className="text-gray-600">{editInterviewId ? 'Update your interview details' : 'Set up your interview session'}</p>
           </div>
         </div>
         {error && (<div className="mb-6 p-4 bg-red-50 border border-red-200 rounded-lg text-red-700">{error}</div>)}
@@ -210,8 +283,8 @@ export default function CreateInterview({ apiBaseUrl }: CreateInterviewProps) {
             <input type="text" required value={formData.name} onChange={e => setFormData({ ...formData, name: e.target.value })} className="w-full px-4 py-3 border border-gray-300 rounded-lg" placeholder="e.g., Senior Developer Interview" />
           </div>
           <div>
-            <label className="block text-sm font-semibold text-gray-700 mb-2">Objective</label>
-            <textarea required value={formData.objective} onChange={e => setFormData({ ...formData, objective: e.target.value })} rows={3} className="w-full px-4 py-3 border border-gray-300 rounded-lg" placeholder="Describe the role requirements and expectations..." />
+            <label className="block text-sm font-semibold text-gray-700 mb-2">Job Description</label>
+            <textarea required value={formData.job_description} onChange={e => setFormData({ ...formData, job_description: e.target.value })} rows={3} className="w-full px-4 py-3 border border-gray-300 rounded-lg" placeholder="Describe the role requirements and expectations..." />
           </div>
           <div>
             <label className="block text-sm font-semibold text-gray-700 mb-2">Upload JD (optional)</label>
@@ -223,6 +296,23 @@ export default function CreateInterview({ apiBaseUrl }: CreateInterviewProps) {
             />
             <p className="text-xs text-gray-500 mt-1">If provided, questions are based on summarized JD.</p>
           </div>
+          <div>
+            <label className="block text-sm font-semibold text-gray-700 mb-2">Department</label>
+            <select
+              value={formData.department}
+              onChange={e => setFormData({ ...formData, department: e.target.value })}
+              className="w-full px-4 py-3 border border-gray-300 rounded-lg"
+            >
+              <option value="">Select department</option>
+              <option value="Design">Design</option>
+              <option value="Data">Data</option>
+              <option value="DevOps">DevOps</option>
+              <option value="QA">QA</option>
+              <option value="Sales">Sales</option>
+              <option value="Marketing">Marketing</option>
+              <option value="HR">HR</option>
+            </select>
+          </div>
           <div className="flex w-full space-x-4">
             <div className="flex-1">
               <label className="block text-sm font-semibold text-gray-700 mb-2">Number of Questions</label>
@@ -268,7 +358,7 @@ export default function CreateInterview({ apiBaseUrl }: CreateInterviewProps) {
             <p className="text-xs text-gray-500 mt-1">Questions will be generated at this difficulty level.</p>
             </div>
           <button type="submit" disabled={loading} className="w-full bg-blue-600 text-white py-4 rounded-lg font-semibold hover:bg-blue-700 transition disabled:opacity-50 disabled:cursor-not-allowed shadow-lg hover:shadow-xl">
-            {loading ? 'Creating...' : 'Create Interview'}
+            {loading ? (editInterviewId ? 'Updating...' : 'Creating...') : (editInterviewId ? 'Update Interview' : 'Create Interview')}
           </button>
         </form>
       </div>
@@ -282,7 +372,25 @@ export default function CreateInterview({ apiBaseUrl }: CreateInterviewProps) {
           onSave={handleModalSave}
           onClose={() => {
             setShowModal(false);
-            handleModalSave(); // Redirect anyway
+            if (editInterviewId) {
+              // If editing, redirect to interview detail page
+              window.history.pushState({}, '', `/interviews/${editInterviewId}`);
+              window.dispatchEvent(new PopStateEvent('popstate'));
+            } else {
+              // If creating, show add candidate dialog
+              setShowAddCandidateDialog(true);
+            }
+          }}
+        />
+      )}
+      
+      {showAddCandidateDialog && createdInterviewId && (
+        <AddCandidateDialog
+          interviewId={createdInterviewId}
+          apiBaseUrl={apiBaseUrl}
+          onClose={handleAddCandidateDialogClose}
+          onSuccess={() => {
+            // Optionally show success message or keep dialog open for more candidates
           }}
         />
       )}
diff --git a/frontend/src/components/EditQuestionsModal.tsx b/frontend/src/components/EditQuestionsModal.tsx
index 0fafdbf..e393a59 100644
--- a/frontend/src/components/EditQuestionsModal.tsx
+++ b/frontend/src/components/EditQuestionsModal.tsx
@@ -34,12 +34,12 @@ export default function EditQuestionsModal({
   const [error, setError] = useState('');
 
   useEffect(() => {
-    // First, try to load existing questions from the interview
+    // Reload questions when questionCount changes (e.g., when editing interview)
     loadExistingQuestions();
-  }, []);
+  }, [questionCount, interviewId]);
 
   const loadExistingQuestions = async () => {
-    let existingQuestions = false;
+    let loadedQuestions: Question[] = [];
     try {
       const res = await fetch(`${apiBaseUrl}/api/interview/list-interviews`, {
         method: 'GET',
@@ -62,14 +62,11 @@ export default function EditQuestionsModal({
         
         if (data.questions && data.questions.length > 0) {
           // Load existing questions
-          const formatted = data.questions.map((q: any) => ({
+          loadedQuestions = data.questions.map((q: any) => ({
             id: q.id,
             question: q.question || q.text || '',
             depth_level: (q.difficulty || q.depth_level || 'medium') as 'low' | 'medium' | 'high',
           }));
-          setQuestions(formatted);
-          existingQuestions = true;
-          return;
         }
       }
     } catch (e) {
@@ -77,18 +74,33 @@ export default function EditQuestionsModal({
     }
 
     // For dynamic mode, don't load/generate questions - they're created during interview
-    // Description should already be generated at interview creation time
     if (mode === 'dynamic') {
       setQuestions([]);
-      return; // Description should already be loaded from existing interview
+      return;
     }
 
-    // For predefined mode: if questions already exist (from auto-generation at creation), use them
-    // Otherwise, generate or initialize based on autoGenerate flag
-    if (autoGenerate && !existingQuestions) {
-      // Only generate if questions don't already exist (weren't auto-generated at creation)
+    // For predefined mode: handle existing questions and question count changes
+    if (loadedQuestions.length > 0) {
+      // If question count increased, add empty questions; if decreased, trim the list
+      if (loadedQuestions.length < questionCount) {
+        // Question count increased - add empty questions
+        const newQuestions = Array(questionCount - loadedQuestions.length).fill(null).map(() => ({ question: '', depth_level: 'medium' as const }));
+        setQuestions([...loadedQuestions, ...newQuestions]);
+      } else if (loadedQuestions.length > questionCount) {
+        // Question count decreased - trim the list
+        setQuestions(loadedQuestions.slice(0, questionCount));
+      } else {
+        // Count matches - use existing questions
+        setQuestions(loadedQuestions);
+      }
+      return;
+    }
+    
+    // If no existing questions, generate or initialize based on autoGenerate flag
+    if (autoGenerate) {
+      // Generate new questions with the updated count
       generateQuestions();
-    } else if (!autoGenerate) {
+    } else {
       // Manual mode: initialize empty questions
       setQuestions(Array(questionCount).fill(null).map(() => ({ question: '', depth_level: 'medium' as const })));
     }
@@ -181,10 +193,10 @@ export default function EditQuestionsModal({
       }
       
       if (description) {
-        // Update description field (which maps to interview.description or objective)
+        // Update description field (which maps to interview.description or job_description)
         fd.append('description', description);
-        // Also update objective field
-        fd.append('objective', description);
+        // Also update job_description field
+        fd.append('job_description', description);
       }
 
       fd.append('interview_id', interviewId);
diff --git a/frontend/src/components/InterviewDetail.tsx b/frontend/src/components/InterviewDetail.tsx
index 3d71dcc..82ad9c0 100644
--- a/frontend/src/components/InterviewDetail.tsx
+++ b/frontend/src/components/InterviewDetail.tsx
@@ -11,6 +11,7 @@ export default function InterviewDetail({ apiBaseUrl, interviewId }: Props) {
   const [interviewMeta, setInterviewMeta] = useState<any>(null);
   const [overallAnalysis, setOverallAnalysis] = useState<any>(null);
   const [loadingAnalysis, setLoadingAnalysis] = useState(false);
+  const [selectedVideo, setSelectedVideo] = useState<{url: string, name: string} | null>(null);
 
   useEffect(() => {
     let cancelled = false;
@@ -205,7 +206,7 @@ export default function InterviewDetail({ apiBaseUrl, interviewId }: Props) {
                     {/* Interview Description */}
                     <div className="mb-6">
                       <h2 className="font-semibold mb-2">Interview Description</h2>
-                      <p className="text-gray-700">{overallAnalysis.interview?.objective || overallAnalysis.interview?.description || 'No description available'}</p>
+                      <p className="text-gray-700">{overallAnalysis.interview?.job_description || overallAnalysis.interview?.description || 'No description available'}</p>
                     </div>
                   </div>
 
@@ -235,20 +236,83 @@ export default function InterviewDetail({ apiBaseUrl, interviewId }: Props) {
                           {overallAnalysis.candidates?.map((candidate: any) => (
                             <tr key={candidate.response_id} className="hover:bg-gray-50">
                               <td className="px-4 py-3">
-                                <a
-                                  href={`/interviews/${interviewId}/responses/${candidate.response_id}`}
-                                  onClick={(e) => {
-                                    e.preventDefault();
-                                    window.history.pushState({}, '', `/interviews/${interviewId}/responses/${candidate.response_id}`);
-                                    window.dispatchEvent(new PopStateEvent('popstate'));
-                                  }}
-                                  className="text-blue-600 hover:underline flex items-center gap-1"
-                                >
-                                  {candidate.name || 'Anonymous'}
-                                  <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
-                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14" />
-                                  </svg>
-                                </a>
+                                <div className="flex items-center gap-3">
+                                  {candidate.image_url ? (
+                                    <img 
+                                      src={`${apiBaseUrl}/api/media/files/${candidate.image_url}`}
+                                      alt={candidate.name || 'Candidate'}
+                                      className="w-10 h-10 rounded-full object-cover"
+                                      onError={(e) => {
+                                        const target = e.target as HTMLImageElement;
+                                        target.style.display = 'none';
+                                      }}
+                                    />
+                                  ) : (
+                                    <div className="w-10 h-10 rounded-full bg-purple-600 flex items-center justify-center text-white font-semibold text-sm">
+                                      {(candidate.name || 'C')[0].toUpperCase()}
+                                    </div>
+                                  )}
+                                  <div className="flex-1">
+                                    <a
+                                      href={`/interviews/${interviewId}/responses/${candidate.response_id}`}
+                                      onClick={(e) => {
+                                        e.preventDefault();
+                                        window.history.pushState({}, '', `/interviews/${interviewId}/responses/${candidate.response_id}`);
+                                        window.dispatchEvent(new PopStateEvent('popstate'));
+                                      }}
+                                      className="text-blue-600 hover:underline flex items-center gap-1"
+                                    >
+                                      {candidate.name || 'Anonymous'}
+                                      <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
+                                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14" />
+                                      </svg>
+                                    </a>
+                                    {candidate.video_url && (
+                                      <button
+                                        onClick={() => {
+                                          const url = candidate.video_url || '';
+                                          let videoUrl: string;
+                                          
+                                          if (!url) {
+                                            return;
+                                          }
+                                          
+                                          // If it's a full URL, extract the path and use current apiBaseUrl
+                                          if (url.startsWith('http://') || url.startsWith('https://')) {
+                                            try {
+                                              const urlObj = new URL(url);
+                                              const path = urlObj.pathname;
+                                              // Normalize path: remove leading double slashes
+                                              const normalized = path.replace(/^\/+/, '/');
+                                              videoUrl = `${apiBaseUrl}${normalized}`;
+                                            } catch (e) {
+                                              // If URL parsing fails, try to extract path manually
+                                              const match = url.match(/\/api\/media\/files\/videos\/[^\/]+\.mp4/);
+                                              if (match) {
+                                                const normalized = match[0].replace(/^\/+/, '/');
+                                                videoUrl = `${apiBaseUrl}${normalized}`;
+                                              } else {
+                                                videoUrl = url; // Fallback to original URL
+                                              }
+                                            }
+                                          } else {
+                                            // Normalize relative URLs: remove leading double slashes
+                                            const normalized = url.replace(/^\/+/, '/');
+                                            videoUrl = `${apiBaseUrl}${normalized}`;
+                                          }
+                                          
+                                          setSelectedVideo({url: videoUrl, name: candidate.name || 'Anonymous'});
+                                        }}
+                                        className="text-xs text-blue-600 hover:text-blue-800 mt-1 flex items-center gap-1"
+                                      >
+                                        <svg className="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
+                                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z" />
+                                        </svg>
+                                        Preview Video
+                                      </button>
+                                    )}
+                                  </div>
+                                </div>
                               </td>
                               <td className="px-4 py-3 font-semibold">{candidate.overall_score || 0}</td>
                               <td className="px-4 py-3">{candidate.communication_score || 0}</td>
@@ -410,6 +474,33 @@ export default function InterviewDetail({ apiBaseUrl, interviewId }: Props) {
           )}
         </div>
       </div>
+
+      {/* Video Preview Modal */}
+      {selectedVideo && (
+        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4" onClick={() => setSelectedVideo(null)}>
+          <div className="bg-white rounded-lg max-w-4xl w-full p-6" onClick={(e) => e.stopPropagation()}>
+            <div className="flex justify-between items-center mb-4">
+              <h3 className="text-xl font-semibold">Interview Recording - {selectedVideo.name}</h3>
+              <button
+                onClick={() => setSelectedVideo(null)}
+                className="text-gray-500 hover:text-gray-700"
+              >
+                <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
+                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
+                </svg>
+              </button>
+            </div>
+            <video 
+              controls 
+              className="w-full rounded-lg"
+              src={selectedVideo.url}
+              autoPlay
+            >
+              Your browser does not support the video tag.
+            </video>
+          </div>
+        </div>
+      )}
     </div>
   );
 }
diff --git a/frontend/src/components/InterviewSession.tsx b/frontend/src/components/InterviewSession.tsx
index e57ecd1..c09dec9 100644
--- a/frontend/src/components/InterviewSession.tsx
+++ b/frontend/src/components/InterviewSession.tsx
@@ -1,12 +1,15 @@
 import { io, Socket } from 'socket.io-client';
 import { useState, useEffect, useRef } from 'react';
 import { Mic, MicOff, Send, CheckCircle, Loader2, Volume2, Clock } from 'lucide-react';
+import { getApiHeaders } from '../utils/api';
 
 interface InterviewSessionProps {
   interviewId: string;
   candidateName: string;
   candidateEmail: string;
   apiBaseUrl: string;
+  screenPermissionGranted?: boolean;
+  existingScreenStream?: MediaStream | null;
 }
 
 export default function InterviewSession({
@@ -14,6 +17,8 @@ export default function InterviewSession({
   candidateName,
   candidateEmail,
   apiBaseUrl,
+  screenPermissionGranted = false,
+  existingScreenStream = null,
 }: InterviewSessionProps) {
   const [responseId, setResponseId] = useState<string | null>(null);
   const [currentQuestion, setCurrentQuestion] = useState<string>('');
@@ -36,7 +41,37 @@ export default function InterviewSession({
   const [socketConnected, setSocketConnected] = useState(false);
   const timerIntervalRef = useRef<NodeJS.Timeout | null>(null);
 
+  // Screen recording refs
+  const screenRecorderRef = useRef<MediaRecorder | null>(null);
+  const screenChunksRef = useRef<Blob[]>([]);
+  const screenStreamRef = useRef<MediaStream | null>(null);
+  const screenChunkIndexRef = useRef<number>(0);
+  const currentResponseIdRef = useRef<string | null>(null); // Track current response_id for video sending
+  const pendingChunksRef = useRef<Array<{chunk: Blob, resId: string, mimeType: string, chunkIndex: number}>>([]); // Queue for chunks that failed to send
+  
+  // Session info refs for reconnection
+  const sessionInfoRef = useRef<{ interview_id: string; response_id: string } | null>(null);
+  
+  // Security monitoring refs
+  const tabSwitchCountRef = useRef<number>(0);
+  const cheatingAlertsRef = useRef<Array<{ type: string; timestamp: number; details?: string }>>([]);
+  const lastScreenActivityRef = useRef<number>(Date.now());
+  const screenCheckIntervalRef = useRef<NodeJS.Timeout | null>(null);
+  
+  // Camera preview refs
+  const [cameraPreviewStream, setCameraPreviewStream] = useState<MediaStream | null>(null);
+  const cameraPreviewRef = useRef<HTMLVideoElement | null>(null);
+  const [screenSharingStopped, setScreenSharingStopped] = useState(false);
+  
+  // Track if we've already initialized to prevent re-running
+  const sessionInitializedRef = useRef(false);
+
   useEffect(() => {
+    // Prevent re-initialization if already initialized
+    if (sessionInitializedRef.current) {
+      return;
+    }
+    
     let cancelled = false;
     const startSession = async () => {
       setLoading(true);
@@ -63,6 +98,9 @@ export default function InterviewSession({
         const data = await response.json();
         if (cancelled) return;
         
+        // Mark as initialized to prevent re-running
+        sessionInitializedRef.current = true;
+        
         setResponseId(data.response_id);
         
         if (data.duration_minutes && data.duration_minutes > 0) {
@@ -75,18 +113,48 @@ export default function InterviewSession({
             transports: ['websocket'],
           });
 
+          // Store session info for reconnection
+          sessionInfoRef.current = {
+            interview_id: interviewId,
+            response_id: data.response_id
+          };
+
+          const reestablishSession = () => {
+            const sessionInfo = sessionInfoRef.current;
+            if (sessionInfo) {
+              console.log('[DEBUG] Re-establishing interview session on connect/reconnect');
+              socket.emit('start_interview', {
+                interview_id: sessionInfo.interview_id,
+                response_id: sessionInfo.response_id,
+              }, (response: any) => {
+                if (response && response.ok) {
+                  console.log('[DEBUG] Interview session started:', response);
+                } else {
+                  console.error('[ERROR] Failed to start interview session:', response);
+                }
+              });
+            }
+          };
+
           socket.on('connect', () => {
+            console.log('[DEBUG] Socket.IO connected');
             setSocketConnected(true);
-            socket.emit('start_interview', {
-              interview_id: interviewId,
-              response_id: data.response_id,
-            }, (response: any) => {
-              if (response && response.ok) {
-                console.log('[DEBUG] Interview session started:', response);
-              } else {
-                console.error('[ERROR] Failed to start interview session:', response);
+            reestablishSession();
+            
+            // Retry any pending chunks that failed to send
+            const pending = pendingChunksRef.current;
+            if (pending.length > 0) {
+              console.log(`[DEBUG] Retrying ${pending.length} pending chunks...`);
+              // Sort by chunkIndex to maintain order
+              pending.sort((a, b) => a.chunkIndex - b.chunkIndex);
+              for (const pendingChunk of pending) {
+                // Chunk 0 is critical, others are not
+                const isCritical = pendingChunk.chunkIndex === 0;
+                sendVideoChunk(pendingChunk.chunk, pendingChunk.resId, pendingChunk.mimeType, pendingChunk.chunkIndex, isCritical)
+                  .catch(err => console.error(`[ERROR] Failed to retry chunk ${pendingChunk.chunkIndex}:`, err));
               }
-            });
+              pendingChunksRef.current = []; // Clear the queue
+            }
           });
 
           socket.on('disconnect', () => setSocketConnected(false));
@@ -115,6 +183,60 @@ export default function InterviewSession({
             fetchCurrentQuestion(data.response_id);
           }
         }
+
+        // Start camera preview for candidate
+        if (!cancelled) {
+          try {
+            const cameraStream = await navigator.mediaDevices.getUserMedia({ 
+              video: { facingMode: 'user' }, 
+              audio: false 
+            });
+            if (!cancelled) {
+              setCameraPreviewStream(cameraStream);
+            } else {
+              cameraStream.getTracks().forEach(track => track.stop());
+            }
+          } catch (e) {
+            console.warn('Camera preview not available:', e);
+            // Camera preview is optional, don't block interview
+          }
+        }
+
+        // Start screen recording after session begins (if permission was granted)
+        // Use existingScreenStream from props (captured in closure) - only check once
+        if (!cancelled && screenPermissionGranted && data.response_id) {
+          try {
+            console.log('[DEBUG] Starting screen recording with existingScreenStream:', {
+              hasStream: !!existingScreenStream,
+              videoTracks: existingScreenStream?.getVideoTracks().length || 0,
+              audioTracks: existingScreenStream?.getAudioTracks().length || 0
+            });
+            // Only start if not already recording
+            if (!screenRecorderRef.current || screenRecorderRef.current.state === 'inactive') {
+              await startScreenRecording(data.response_id, existingScreenStream);
+            } else {
+              console.log('[DEBUG] Screen recording already active, skipping');
+            }
+          } catch (e) {
+            const errorMessage = e instanceof Error ? e.message : 'Failed to start screen recording';
+            console.error('[ERROR] Failed to start screen recording:', e);
+            console.error('[ERROR] Error details:', {
+              message: errorMessage,
+              hasExistingStream: !!existingScreenStream,
+              screenPermissionGranted
+            });
+            if (!cancelled) {
+              // Only set error if it's not about validation - validation errors should be handled gracefully
+              if (!errorMessage.includes('Full screen sharing') && !errorMessage.includes('enable audio')) {
+                setError(errorMessage);
+              } else {
+                // For validation errors, just log - don't block the interview
+                console.warn('[WARN] Screen sharing validation issue:', errorMessage);
+              }
+            }
+            // Don't block interview if screen recording fails, but show error
+          }
+        }
       } catch (err) {
         if (!cancelled) {
           setError(err instanceof Error ? err.message : 'An error occurred');
@@ -137,7 +259,22 @@ export default function InterviewSession({
       if (socketRef.current) {
         socketRef.current.disconnect();
       }
+      // Cleanup screen recording
+      if (screenRecorderRef.current && screenRecorderRef.current.state !== 'inactive') {
+        screenRecorderRef.current.stop();
+      }
+      if (screenStreamRef.current) {
+        screenStreamRef.current.getTracks().forEach(track => track.stop());
+        screenStreamRef.current = null;
+      }
+      // Cleanup camera preview
+      if (cameraPreviewStream) {
+        cameraPreviewStream.getTracks().forEach(track => track.stop());
+      }
     };
+    
+    // Only run once on mount - dependencies removed to prevent re-initialization
+    // eslint-disable-next-line react-hooks/exhaustive-deps
   }, []);
 
   // Timer countdown effect
@@ -281,6 +418,604 @@ export default function InterviewSession({
     }
   };
 
+  // Update camera preview video element - use ref to prevent re-renders
+  const cameraStreamRef = useRef<MediaStream | null>(null);
+  
+  useEffect(() => {
+    if (!cameraPreviewRef.current) return;
+    
+    const video = cameraPreviewRef.current;
+    
+    // Only update if stream actually changed
+    if (cameraPreviewStream !== cameraStreamRef.current) {
+      cameraStreamRef.current = cameraPreviewStream;
+      
+      if (cameraPreviewStream) {
+        video.srcObject = cameraPreviewStream;
+        video.playsInline = true;
+        video.muted = true;
+        video.autoplay = true;
+        video.play().catch(() => {
+          // Silently fail - autoplay might be blocked
+        });
+      } else {
+        video.srcObject = null;
+      }
+    }
+  }, [cameraPreviewStream]);
+
+  // Helper function to convert Blob to Base64
+  // Uses a simpler, more reliable method that avoids padding issues
+  const convertBlobToBase64 = (blob: Blob): Promise<string> => {
+    return new Promise((resolve, reject) => {
+      const reader = new FileReader();
+      
+      reader.onload = () => {
+        try {
+          const result = reader.result;
+          
+          if (!result || !(result instanceof ArrayBuffer)) {
+            throw new Error(`FileReader returned invalid result type: ${typeof result}`);
+          }
+          
+          // Use a simpler approach: convert entire ArrayBuffer to base64 at once
+          // This avoids padding issues from chunked encoding
+          const bytes = new Uint8Array(result);
+          
+          // Convert to binary string in chunks to avoid stack overflow
+          let binary = '';
+          const chunkSize = 8192; // Process in 8KB chunks
+          for (let i = 0; i < bytes.length; i += chunkSize) {
+            const chunk = bytes.subarray(i, Math.min(i + chunkSize, bytes.length));
+            // Build string character by character to avoid apply() stack issues
+            for (let j = 0; j < chunk.length; j++) {
+              binary += String.fromCharCode(chunk[j]);
+            }
+          }
+          
+          // Encode to base64
+          const base64 = btoa(binary);
+          
+          // Validate the result
+          const expectedLength = Math.ceil(blob.size * 4 / 3);
+          if (base64.length < expectedLength * 0.9) {
+            throw new Error(`Base64 string too short: ${base64.length} (expected ~${expectedLength} for blob size ${blob.size})`);
+          }
+          
+          // For chunk 0, verify the first few bytes after decoding
+          if (bytes.length >= 4) {
+            const header = Array.from(bytes.slice(0, 4)).map(b => b.toString(16).padStart(2, '0')).join('');
+            console.log(`[DEBUG] Blob header bytes (first 4): ${header}`);
+          }
+          
+          console.log(`[DEBUG] Converted blob to base64 - blob size: ${blob.size}, base64 length: ${base64.length}`);
+          
+          resolve(base64);
+        } catch (err) {
+          console.error(`[ERROR] Error in convertBlobToBase64:`, err);
+          reject(err);
+        }
+      };
+      
+      reader.onerror = (error) => {
+        console.error(`[ERROR] FileReader error:`, error);
+        reject(new Error(`Failed to read blob: ${error}`));
+      };
+      
+      console.log(`[DEBUG] Starting FileReader.readAsArrayBuffer for blob: ${blob.size} bytes, type: ${blob.type}`);
+      reader.readAsArrayBuffer(blob);
+    });
+  };
+
+  // Function to send a single video chunk via socketio
+  // For critical chunks (chunk 0), it will reject on failure to enable retry logic
+  const sendVideoChunk = async (chunk: Blob, resId: string, mimeType: string, chunkIndex: number, isCritical: boolean = false): Promise<void> => {
+    if (!chunk || chunk.size === 0) {
+      const error = new Error('Cannot send empty video chunk');
+      if (isCritical) throw error;
+      console.error('[ERROR]', error.message);
+      return;
+    }
+
+    // Check socket connection
+    let socket = socketRef.current;
+    if (!socket || !socket.connected) {
+      console.log(`[DEBUG] Socket not ready yet for chunk ${chunkIndex}, waiting up to 10s for connection...`);
+      const waitStart = Date.now();
+      const maxWait = 10000; // 10 seconds max wait (increased for initial connection)
+      
+      while ((!socket || !socket.connected) && (Date.now() - waitStart) < maxWait) {
+        await new Promise(resolve => setTimeout(resolve, 100));
+        socket = socketRef.current;
+      }
+    }
+
+    if (!socket || !socket.connected) {
+      const error = new Error(`Socket not connected after wait for chunk ${chunkIndex}`);
+      console.warn(`[WARN] ${error.message}, queueing chunk for retry`);
+      // Queue chunk for retry when socket becomes available
+      pendingChunksRef.current.push({chunk, resId, mimeType, chunkIndex});
+      if (isCritical) throw error;
+      return;
+    }
+
+    try {
+      // Convert chunk to base64 (chunks are smaller, so this is fast)
+      const base64String = await convertBlobToBase64(chunk);
+      
+      // Extract file extension
+      const fileExtension = mimeType.includes('webm') ? 'webm' : 
+                           mimeType.includes('mp4') ? 'mp4' : 'webm';
+
+      // Send via socketio with timeout
+      return new Promise<void>((resolve, reject) => {
+        const timeout = setTimeout(() => {
+          socket.off('video_chunk_saved', handler);
+          socket.off('error', errorHandler);
+          const error = new Error(`Timeout waiting for chunk ${chunkIndex} confirmation (chunk size: ${chunk.size} bytes)`);
+          console.warn(`[WARN] ${error.message}`);
+          if (isCritical) {
+            reject(error);
+          } else {
+            resolve(); // Non-critical chunks resolve to not block
+          }
+        }, 8000); // 8 second timeout for individual chunks (increased for large chunks)
+
+        const handler = (response: any) => {
+          if (response && response.ok) {
+            clearTimeout(timeout);
+            socket.off('video_chunk_saved', handler);
+            socket.off('error', errorHandler);
+            resolve();
+          } else if (isCritical) {
+            clearTimeout(timeout);
+            socket.off('video_chunk_saved', handler);
+            socket.off('error', errorHandler);
+            reject(new Error(`Chunk ${chunkIndex} save failed: ${response?.error || 'Unknown error'}`));
+          } else {
+            clearTimeout(timeout);
+            socket.off('video_chunk_saved', handler);
+            socket.off('error', errorHandler);
+            resolve(); // Non-critical chunks resolve even on failure
+          }
+        };
+
+        const errorHandler = (error: any) => {
+          clearTimeout(timeout);
+          socket.off('video_chunk_saved', handler);
+          socket.off('error', errorHandler);
+          const errorMsg = error?.error || 'Unknown error';
+          console.warn(`[WARN] Chunk ${chunkIndex} send error: ${errorMsg}`);
+          if (isCritical) {
+            reject(new Error(`Chunk ${chunkIndex} send error: ${errorMsg}`));
+          } else {
+            resolve(); // Non-critical chunks resolve to not block
+          }
+        };
+
+        socket.once('video_chunk_saved', handler);
+        socket.once('error', errorHandler);
+
+        // Log before sending
+        console.log(`[SEND] Sending chunk ${chunkIndex} to backend (${chunk.size} bytes blob, ${base64String.length} chars base64, critical: ${isCritical})`);
+        
+        // Emit the chunk
+        socket.emit('save_video_chunk', {
+          response_id: resId,
+          chunk: base64String,
+          file_extension: fileExtension,
+          chunk_index: chunkIndex
+        });
+      });
+    } catch (err) {
+      const error = err instanceof Error ? err : new Error('Failed to convert/send video chunk');
+      console.error('[ERROR]', error.message, err);
+      if (isCritical) throw error;
+    }
+  };
+
+  const startScreenRecording = async (resId: string, useExistingStream?: MediaStream | null) => {
+    try {
+      // Don't start if already recording
+      if (screenRecorderRef.current && screenRecorderRef.current.state !== 'inactive') {
+        console.log('[DEBUG] Screen recording already active, skipping start');
+        return;
+      }
+      
+      let displayStream: MediaStream | null = null;
+      
+      // Use existing stream if provided (from CandidateStart), otherwise request new one
+      if (useExistingStream && useExistingStream.getVideoTracks().length > 0) {
+        const existingTrack = useExistingStream.getVideoTracks()[0];
+        const existingAudioTracks = useExistingStream.getAudioTracks();
+        const settings = existingTrack.getSettings();
+        const displaySurface = (settings as any).displaySurface;
+        
+        console.log(`[DEBUG] Checking existing screen sharing stream:`, {
+          readyState: existingTrack.readyState,
+          enabled: existingTrack.enabled,
+          displaySurface: displaySurface,
+          audioTracks: existingAudioTracks.length,
+          videoTracks: useExistingStream.getVideoTracks().length
+        });
+        
+        // Ensure the existing track is enabled and active
+        if (!existingTrack.enabled) {
+          existingTrack.enabled = true;
+        }
+        
+        // Only reject if track is explicitly ended - otherwise accept it
+        // The stream was already validated in CandidateStart, so trust it
+        if (existingTrack.readyState === 'ended') {
+          console.warn('[DEBUG] Existing stream track has ended, requesting new stream...');
+          displayStream = null; // Will trigger new stream request below
+        } else {
+          // Stream is good, use it - don't re-validate since CandidateStart already did
+          // Also check if it's the same stream we're already using (compare by first track ID)
+          if (screenStreamRef.current && screenStreamRef.current.getVideoTracks().length > 0) {
+            const currentTrackId = screenStreamRef.current.getVideoTracks()[0].id;
+            const existingTrackId = existingTrack.id;
+            if (currentTrackId === existingTrackId) {
+              console.log('[DEBUG] Already using this stream, skipping re-initialization');
+              return; // Exit early, we're already recording with this stream
+            }
+          }
+          console.log('[DEBUG] Using existing stream without re-validation');
+          displayStream = useExistingStream;
+        }
+      }
+      
+      if (!displayStream) {
+        // Only request new stream if we don't already have an active recording
+        if (screenRecorderRef.current && screenRecorderRef.current.state !== 'inactive') {
+          console.log('[DEBUG] Screen recording already active, not requesting new stream');
+          return;
+        }
+        
+        console.log('[DEBUG] Requesting new screen sharing stream...');
+        const newStream = await (navigator.mediaDevices as any).getDisplayMedia({ 
+          video: { displaySurface: 'monitor' },
+          audio: true 
+        });
+
+        // Validate full screen sharing (reject window/tab-only)
+        const videoTrack = newStream.getVideoTracks()[0];
+        const settings = videoTrack.getSettings();
+        const displaySurface = (settings as any).displaySurface;
+        
+        console.log(`[DEBUG] New stream validation: displaySurface=${displaySurface}, audioTracks=${newStream.getAudioTracks().length}`);
+        
+        // Only reject if we're CERTAIN it's not full screen (displaySurface exists and is NOT 'monitor')
+        // If displaySurface is undefined, it might just be a browser limitation, so accept it
+        if (displaySurface !== undefined && displaySurface !== 'monitor') {
+          newStream.getTracks().forEach((track: MediaStreamTrack) => track.stop());
+          throw new Error('Full screen sharing is required. Please select "Entire Screen" instead of a single window or tab.');
+        }
+
+        // Validate that audio is enabled during screen sharing
+        // Note: Some browsers might not expose audio tracks immediately, so warn but don't reject
+        const audioTracks = newStream.getAudioTracks();
+        if (audioTracks.length === 0) {
+          console.warn('[DEBUG] No audio tracks found in new stream - this might be a browser limitation');
+          // Don't reject - audio might be available but not exposed as a track
+          // We'll still try to get mic audio separately
+        }
+        
+        displayStream = newStream;
+        console.log('[DEBUG] New stream accepted');
+      }
+      
+      // At this point, displayStream is guaranteed to be non-null
+      if (!displayStream) {
+        throw new Error('Failed to obtain screen sharing stream');
+      }
+
+      // Get microphone audio and mix into the final stream
+      let finalStream: MediaStream = displayStream as MediaStream;
+      
+      try {
+        const mic = await navigator.mediaDevices.getUserMedia({ audio: true });
+        const tracks: MediaStreamTrack[] = [];
+        tracks.push(...displayStream.getVideoTracks());
+        
+        // Prefer mic over display audio to ensure voice is captured
+        const audioTracks = [
+          ...mic.getAudioTracks(),
+          ...displayStream.getAudioTracks(),
+        ];
+        
+        // Deduplicate by track ID
+        const uniqueAudio = new Map<string, MediaStreamTrack>();
+        audioTracks.forEach(t => uniqueAudio.set(t.id, t));
+        tracks.push(...uniqueAudio.values());
+        
+        finalStream = new MediaStream(tracks);
+      } catch (e) {
+        // Mic unavailable, proceed with displayStream (may still include tab/system audio)
+        finalStream = displayStream as MediaStream;
+      }
+
+      screenStreamRef.current = finalStream;
+
+      // Verify stream is active before recording
+      const videoTrack = finalStream.getVideoTracks()[0];
+      if (!videoTrack) {
+        throw new Error('No video track found in screen stream. Please ensure screen sharing is enabled.');
+      }
+      
+      // Check if track is enabled and not ended
+      // Note: readyState can be 'live' or 'ended' - we just need it to exist and be enabled
+      if (videoTrack.readyState === 'ended') {
+        throw new Error('Screen sharing track has ended. Please restart screen sharing.');
+      }
+      
+      if (!videoTrack.enabled) {
+        console.warn('[DEBUG] Video track is disabled, enabling it...');
+        videoTrack.enabled = true;
+      }
+      
+      // Log detailed stream info for debugging
+      const streamSettings = videoTrack.getSettings();
+      console.log(`[DEBUG] Stream verified for recording:`, {
+        readyState: videoTrack.readyState,
+        enabled: videoTrack.enabled,
+        trackId: videoTrack.id,
+        displaySurface: (streamSettings as any).displaySurface,
+        audioTracks: finalStream.getAudioTracks().length,
+        videoTracks: finalStream.getVideoTracks().length
+      });
+
+      // Handle user stopping sharing via browser UI
+      videoTrack.onended = () => {
+        console.warn('Screen sharing was stopped by user');
+        recordCheatingAlert('screen_sharing_stopped', 'User stopped screen sharing');
+        setScreenSharingStopped(true);
+        stopScreenRecording(resId);
+        setError(' Screen sharing was stopped! Please restart screen sharing to continue the interview.');
+      };
+
+      // Monitor screen activity for black screens/pauses
+      startScreenActivityMonitoring();
+
+      // Determine best MIME type
+      const mime = (() => {
+        const preferred = 'video/webm;codecs=vp9,opus';
+        if (MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported(preferred)) {
+          return preferred;
+        }
+        return 'video/webm';
+      })();
+
+      console.log(`[DEBUG] Creating MediaRecorder with mime: ${mime}, stream tracks: video=${finalStream.getVideoTracks().length}, audio=${finalStream.getAudioTracks().length}`);
+      const screenRecorder = new MediaRecorder(finalStream, { mimeType: mime });
+      console.log(`[DEBUG] MediaRecorder created. State: ${screenRecorder.state}, mimeType: ${screenRecorder.mimeType}`);
+      
+      screenRecorderRef.current = screenRecorder;
+      screenChunksRef.current = [];
+      screenChunkIndexRef.current = 0;
+      currentResponseIdRef.current = resId; // Store response_id for later use
+      
+      // Track chunk count for timeslice switching
+      let earlyChunkCount = 0;
+
+      // Step 1: Collect chunks and send them in real-time (non-blocking)
+      screenRecorder.ondataavailable = async (e: BlobEvent) => {
+        const currentIndex = screenChunkIndexRef.current;
+        console.log(`[DEBUG] ondataavailable fired - chunk index: ${currentIndex}, data exists: ${!!e.data}, size: ${e.data?.size || 0}, type: ${e.data?.type || 'unknown'}`);
+        
+        if (e.data && e.data.size > 0) {
+          // Minimum chunk size threshold - but be more lenient for early chunks
+          // Early chunks (0-3) might be smaller fragments, so we accept them
+          const MIN_CHUNK_SIZE = currentIndex <= 3 ? 50 : 100;
+          
+          if (e.data.size < MIN_CHUNK_SIZE) {
+            // For early chunks, log but don't skip (they might be important fragments)
+            if (currentIndex <= 3) {
+              console.warn(`[WARN] Chunk ${currentIndex} is small (${e.data.size} bytes) but accepting it as early fragment`);
+            } else {
+              console.error(`[ERROR] Skipping chunk ${currentIndex} that is too small: ${e.data.size} bytes (minimum: ${MIN_CHUNK_SIZE} bytes). MediaRecorder may not be capturing properly.`);
+              console.error(`[ERROR] Stream active tracks: video=${finalStream.getVideoTracks().length}, audio=${finalStream.getAudioTracks().length}`);
+              console.error(`[ERROR] Video track readyState: ${finalStream.getVideoTracks()[0]?.readyState}, enabled: ${finalStream.getVideoTracks()[0]?.enabled}`);
+              return; // Skip this chunk
+            }
+          }
+          
+          // Collect the chunk
+          screenChunksRef.current.push(e.data);
+          const chunkIndex = screenChunkIndexRef.current;
+          console.log(`[DEBUG] Collected chunk: ${e.data.size} bytes, type: ${e.data.type}, total chunks: ${screenChunksRef.current.length}, index: ${chunkIndex}`);
+          
+          // For chunk 0, validate EBML header before sending
+          if (chunkIndex === 0) {
+            // Validate chunk 0 has proper WebM EBML header
+            const validateChunk0 = async (blob: Blob): Promise<boolean> => {
+              try {
+                const arrayBuffer = await blob.slice(0, 4).arrayBuffer();
+                const header = new Uint8Array(arrayBuffer);
+                const expectedHeader = new Uint8Array([0x1a, 0x45, 0xdf, 0xa3]);
+                const isValid = header.length === 4 && 
+                  header[0] === expectedHeader[0] &&
+                  header[1] === expectedHeader[1] &&
+                  header[2] === expectedHeader[2] &&
+                  header[3] === expectedHeader[3];
+                
+                if (!isValid) {
+                  const headerHex = Array.from(header).map(b => b.toString(16).padStart(2, '0')).join('');
+                  console.error(`[ERROR] CRITICAL: Chunk 0 has invalid EBML header! Got: ${headerHex}, Expected: 1a45dfa3`);
+                  return false;
+                } else {
+                  console.log(`[DEBUG]  Chunk 0 has valid EBML header (1a45dfa3)`);
+                  return true;
+                }
+              } catch (err) {
+                console.error(`[ERROR] Failed to validate chunk 0 header:`, err);
+                return false;
+              }
+            };
+            
+            const isValidHeader = await validateChunk0(e.data);
+            if (!isValidHeader) {
+              console.error(`[ERROR] CRITICAL: Chunk 0 validation failed - will still attempt to send but merge may fail`);
+              // Still try to send it, but log the error
+            }
+          }
+          
+          // For chunk 0, wait for confirmation to ensure it's sent (critical for EBML header)
+          if (chunkIndex === 0) {
+            console.log(`[DEBUG] Sending critical chunk 0 (EBML header) - awaiting confirmation...`);
+            try {
+              // Retry chunk 0 up to 3 times if it fails
+              let retries = 0;
+              const maxRetries = 3;
+              let success = false;
+              
+              while (retries < maxRetries && !success) {
+                try {
+                  await sendVideoChunk(e.data, resId, e.data.type || mime, chunkIndex, true); // isCritical = true
+                  console.log(`[DEBUG] Chunk 0 confirmed as sent (attempt ${retries + 1})`);
+                  success = true;
+                } catch (err) {
+                  retries++;
+                  if (retries < maxRetries) {
+                    console.warn(`[WARN] Chunk 0 send failed (attempt ${retries}), retrying in 1s...`, err);
+                    await new Promise(resolve => setTimeout(resolve, 1000));
+                  } else {
+                    console.error(`[ERROR] CRITICAL: Failed to send chunk 0 (EBML header) after ${maxRetries} attempts:`, err);
+                    // Queue it for retry when socket connects
+                    pendingChunksRef.current.push({chunk: e.data, resId, mimeType: e.data.type || mime, chunkIndex});
+                  }
+                }
+              }
+            } catch (err) {
+              console.error(`[ERROR] CRITICAL: Failed to send chunk 0 (EBML header):`, err);
+              // Queue it for retry when socket connects
+              pendingChunksRef.current.push({chunk: e.data, resId, mimeType: e.data.type || mime, chunkIndex});
+            }
+          } else {
+            // Send other chunks immediately via socketio (non-blocking, don't await)
+            // But queue them for retry if they fail
+            sendVideoChunk(e.data, resId, e.data.type || mime, chunkIndex, false).catch(err => {
+              console.error(`[ERROR] Failed to send chunk ${chunkIndex}:`, err);
+              // Queue for retry when socket connects (important for maintaining sequence)
+              pendingChunksRef.current.push({chunk: e.data, resId, mimeType: e.data.type || mime, chunkIndex});
+              console.log(`[DEBUG] Queued chunk ${chunkIndex} for retry`);
+            });
+          }
+          
+          // Only increment chunk index after successful processing
+          // This ensures we don't skip indices if chunks fail
+          screenChunkIndexRef.current++;
+          
+          // After capturing first 4 chunks (0-3), switch to longer timeslice for efficiency
+          // BUT: Don't stop/restart as it can cause chunk loss. Instead, just let it continue.
+          // The 2s timeslice is fine for the entire recording - it ensures all chunks are captured.
+          earlyChunkCount++;
+          if (earlyChunkCount === 4) {
+            console.log(`[DEBUG] Captured first 4 chunks. Continuing with 2s timeslice to ensure all chunks are captured.`);
+            // Note: We're NOT switching timeslice anymore to avoid losing chunks during restart
+          }
+        } else {
+          console.warn('[DEBUG] Received empty or null chunk data');
+        }
+      };
+
+      screenRecorder.onerror = (event: any) => {
+        console.error(`[ERROR] MediaRecorder error:`, event);
+        console.error(`[ERROR] Error details:`, event.error);
+      };
+      
+      screenRecorder.onstart = () => {
+        console.log(`[DEBUG] MediaRecorder started successfully. State: ${screenRecorder.state}`);
+      };
+      
+      screenRecorder.onstop = async () => {
+        const resId = currentResponseIdRef.current;
+        const totalCollected = screenChunksRef.current.length;
+        const totalSent = screenChunkIndexRef.current;
+        
+        console.log(`[DEBUG] Screen recorder stopped. Total chunks collected: ${totalCollected}, chunks sent: ${totalSent} for response_id: ${resId}`);
+        
+        // Chunks are already being sent in real-time, so we just need to wait a bit
+        // for any final chunks to be processed
+        if (totalSent < totalCollected) {
+          console.log(`[DEBUG] Waiting for remaining chunks to be sent (${totalCollected - totalSent} remaining)...`);
+          // Wait a bit for final chunks to be sent
+          await new Promise(resolve => setTimeout(resolve, 2000));
+        }
+        
+        console.log(`[DEBUG] Screen recording stopped. All chunks should be uploaded. Merge will be triggered when interview ends.`);
+      };
+      
+      // Store resId for use in stopScreenRecording
+      (screenRecorder as any)._resId = resId;
+
+      // Start recording with a shorter initial timeslice to capture early chunks
+      // Then switch to longer timeslice after first few chunks
+      screenRecorder.start(2000); // Start with 2 second timeslice to capture chunks 0-3
+      console.log(`[DEBUG] Screen recording started for response_id: ${resId}, recorder state: ${screenRecorder.state}, initial timeslice: 2000ms`);
+      
+      // CRITICAL: Request the first chunk immediately to get the EBML header
+      // This ensures chunk 0 is captured right away with the proper header
+      setTimeout(() => {
+        if (screenRecorder.state === 'recording') {
+          console.log(`[DEBUG] Requesting initial chunk (chunk 0) to capture EBML header...`);
+          try {
+            screenRecorder.requestData();
+          } catch (err) {
+            console.error(`[ERROR] Failed to request initial chunk:`, err);
+          }
+        }
+      }, 500); // Small delay to ensure recorder is fully started
+    } catch (e) {
+      console.error('Failed to start screen recording:', e);
+      throw e;
+    }
+  };
+
+  const stopScreenRecording = async (_resId: string) => {
+    try {
+      const recorder = screenRecorderRef.current;
+      if (recorder && recorder.state !== 'inactive') {
+        // Request any remaining data before stopping
+        try {
+          if (recorder.state === 'recording') {
+            recorder.requestData();
+            // Wait a bit for the data to be available
+            await new Promise(resolve => setTimeout(resolve, 500));
+          }
+        } catch (e) {
+          console.warn('[DEBUG] Could not request data before stop:', e);
+        }
+        
+        const originalOnStop = recorder.onstop;
+        const stopPromise = new Promise<void>((resolve) => {
+          recorder.onstop = async () => {
+            if (originalOnStop) {
+              try {
+                await (originalOnStop as any).call(recorder, new Event('stop'));
+              } catch (e) {
+                console.error('Error in original onstop handler:', e);
+              }
+            }
+            // Note: Video merge is now triggered when results page loads, not here
+            // This ensures chunks are fully uploaded before merge
+            console.log('[DEBUG] Screen recording stopped. Merge will be triggered when results page loads.');
+            resolve();
+          };
+        });
+        recorder.stop();
+        await stopPromise;
+      }
+
+      if (screenStreamRef.current) {
+        screenStreamRef.current.getTracks().forEach(track => track.stop());
+        screenStreamRef.current = null;
+      }
+    } catch (e) {
+      console.warn('Error stopping screen recording:', e);
+    }
+  };
+
   const startRecording = async () => {
     if (!socketRef.current || !socketConnected) {
       setError('Socket not connected. Please wait...');
@@ -334,6 +1069,12 @@ export default function InterviewSession({
   // Removed transcribeAudio(): live transcript arrives via socket 'transcript_result'
 
   const toggleRecording = () => {
+    // Block recording if screen sharing is stopped
+    if (screenSharingStopped) {
+      setError(' Cannot record: Screen sharing is required. Please restart screen sharing to continue.');
+      return;
+    }
+
     if (isRecording) {
       stopRecording();
     } else {
@@ -341,18 +1082,82 @@ export default function InterviewSession({
     }
   };
 
+  // Function to restart screen sharing
+  const restartScreenSharing = async () => {
+    if (!responseId) return;
+    
+    try {
+      setError('');
+      // Pass null to request a new stream (since the old one was stopped)
+      await startScreenRecording(responseId, null);
+      setScreenSharingStopped(false);
+    } catch (e) {
+      const errorMessage = e instanceof Error ? e.message : 'Failed to restart screen sharing';
+      setError(errorMessage);
+    }
+  };
+
+  // Helper function to ensure final chunks are sent (chunks are already sent in real-time)
+  const sendVideoIfRecording = async (resId: string): Promise<void> => {
+    const recorder = screenRecorderRef.current;
+    if (!recorder || recorder.state === 'inactive') {
+      console.log('[DEBUG] No active recording, skipping video send');
+      return;
+    }
+
+    const chunks = screenChunksRef.current;
+    if (chunks.length === 0) {
+      console.log('[DEBUG] No chunks collected, skipping video send');
+      return;
+    }
+
+    try {
+      // Request any remaining data before stopping
+      if (recorder.state === 'recording') {
+        recorder.requestData();
+        // Wait a bit for the data to be available and sent
+        await new Promise(resolve => setTimeout(resolve, 1000));
+      }
+
+      // Chunks are already being sent in real-time, so we just wait a bit
+      // for any final chunks to be processed
+      const totalCollected = chunks.length;
+      const totalSent = screenChunkIndexRef.current;
+      
+      if (totalSent < totalCollected) {
+        console.log(`[DEBUG] Waiting for remaining chunks to be sent (${totalCollected - totalSent} remaining)...`);
+        await new Promise(resolve => setTimeout(resolve, 2000));
+      }
+      
+      console.log(`[DEBUG] Video chunks sent: ${screenChunkIndexRef.current}/${totalCollected} for response_id: ${resId}`);
+    } catch (err) {
+      console.error(`[ERROR] Failed to process video chunks:`, err);
+      // Don't throw - allow answer submission to continue
+    }
+  };
+
   const submitAnswer = async () => {
     if (!responseId || !transcript.trim() || transcript === 'Recording...') {
       setError('Please record an answer first');
       return;
     }
 
+    // Block submission if screen sharing is stopped
+    if (screenSharingStopped) {
+      setError(' Cannot submit: Screen sharing is required. Please restart screen sharing to continue.');
+      return;
+    }
+
     setLoading(true);
     try {
       // Ensure recording is stopped before submitting
       if (isRecording) {
         stopRecording();
       }
+
+      // Send video if recording was active (SubmitAnswer - normal answer submission)
+      await sendVideoIfRecording(responseId);
+
       const response = await fetch(`${apiBaseUrl}/api/interview/submit-answer`, {
         method: 'POST',
         headers: {
@@ -423,6 +1228,14 @@ export default function InterviewSession({
 
     setLoading(true);
     try {
+      // Send video if recording was active (end interview - final chunk)
+      await sendVideoIfRecording(responseId);
+
+      // Stop screen recording before ending interview
+      if (screenRecorderRef.current) {
+        await stopScreenRecording(responseId);
+      }
+
       // Signal socket stream end for live STT consolidation/cleanup
       if (socketRef.current) {
         try { socketRef.current.emit('end_interview'); } catch {}
@@ -457,9 +1270,7 @@ export default function InterviewSession({
         try {
           const detailRes = await fetch(`${apiBaseUrl}/api/interview/get-response?response_id=${encodeURIComponent(responseId)}`, {
             method: 'GET',
-            headers: {
-              'Content-Type': 'application/json',
-            },
+            headers: getApiHeaders(false),
           });
           if (detailRes.ok) {
             const detailData = await detailRes.json();
@@ -476,6 +1287,126 @@ export default function InterviewSession({
     }
   };
 
+  // Tab switch detection and cheating monitoring
+  useEffect(() => {
+    if (!responseId || interviewComplete) return;
+
+    const handleVisibilityChange = () => {
+      if (document.hidden) {
+        tabSwitchCountRef.current++;
+        recordCheatingAlert('tab_switch', `Tab switched (count: ${tabSwitchCountRef.current})`);
+        setError(` Warning: You switched tabs. This is being monitored. (Count: ${tabSwitchCountRef.current})`);
+        
+        // If too many tab switches, end interview
+        if (tabSwitchCountRef.current >= 3) {
+          setError('Interview terminated: Multiple tab switches detected. This indicates suspicious activity.');
+          endInterviewManually();
+        }
+      } else {
+        lastScreenActivityRef.current = Date.now();
+      }
+    };
+
+    const handleBlur = () => {
+      recordCheatingAlert('window_blur', 'Window lost focus');
+    };
+
+    const handleFocus = () => {
+      lastScreenActivityRef.current = Date.now();
+    };
+
+    document.addEventListener('visibilitychange', handleVisibilityChange);
+    window.addEventListener('blur', handleBlur);
+    window.addEventListener('focus', handleFocus);
+
+    return () => {
+      document.removeEventListener('visibilitychange', handleVisibilityChange);
+      window.removeEventListener('blur', handleBlur);
+      window.removeEventListener('focus', handleFocus);
+    };
+    // eslint-disable-next-line react-hooks/exhaustive-deps
+  }, [responseId, interviewComplete]);
+
+  // Screen activity monitoring for black screens/pauses
+  const startScreenActivityMonitoring = () => {
+    if (screenCheckIntervalRef.current) {
+      clearInterval(screenCheckIntervalRef.current);
+    }
+
+    screenCheckIntervalRef.current = setInterval(() => {
+      if (!screenStreamRef.current || interviewComplete) {
+        if (screenCheckIntervalRef.current) {
+          clearInterval(screenCheckIntervalRef.current);
+          screenCheckIntervalRef.current = null;
+        }
+        return;
+      }
+
+      const videoTrack = screenStreamRef.current.getVideoTracks()[0];
+      if (!videoTrack) {
+        // Track might have ended - this is handled by the onended handler
+        return;
+      }
+      
+      // Only alert if track is ended (not just paused or muted)
+      if (videoTrack.readyState === 'ended') {
+        recordCheatingAlert('screen_track_inactive', 'Screen track has ended');
+        return;
+      }
+
+      // Update activity timestamp if track is live
+      if (videoTrack.readyState === 'live') {
+        lastScreenActivityRef.current = Date.now();
+      }
+
+      // Check for screen pause (no activity for extended period)
+      const now = Date.now();
+      const timeSinceActivity = now - lastScreenActivityRef.current;
+      
+      if (timeSinceActivity > 30000) { // 30 seconds of inactivity
+        recordCheatingAlert('screen_pause', `Screen paused for ${Math.floor(timeSinceActivity / 1000)}s`);
+      }
+    }, 5000); // Check every 5 seconds
+  };
+
+  const recordCheatingAlert = (type: string, details?: string) => {
+    cheatingAlertsRef.current.push({
+      type,
+      timestamp: Date.now(),
+      details
+    });
+    console.warn(`[SECURITY ALERT] ${type}:`, details);
+    
+    // Optionally send to backend for logging (endpoint may not exist, so we catch errors)
+    if (responseId) {
+      // Async send - don't block
+      fetch(`${apiBaseUrl}/api/interview/record-cheating-alert`, {
+        method: 'POST',
+        headers: getApiHeaders(false), // Candidate endpoint, no API key needed
+        body: JSON.stringify({
+          response_id: responseId,
+          alert_type: type,
+          details: details,
+          timestamp: Date.now()
+        })
+      }).catch(err => {
+        // Silently fail - endpoint may not exist
+        console.debug('Cheating alert endpoint not available:', err);
+      });
+    }
+  };
+
+  // Stop and upload screen recording when interview completes naturally
+  useEffect(() => {
+    if (interviewComplete && responseId && screenRecorderRef.current) {
+      stopScreenRecording(responseId);
+      if (screenCheckIntervalRef.current) {
+        clearInterval(screenCheckIntervalRef.current);
+        screenCheckIntervalRef.current = null;
+      }
+    }
+  }, [interviewComplete, responseId]);
+
   if (interviewComplete) {
     return (
       <div className="min-h-screen bg-gradient-to-br from-emerald-50 to-teal-50 flex items-center justify-center p-6">
@@ -559,6 +1490,45 @@ export default function InterviewSession({
           <p className="text-gray-600">Candidate: {candidateName}</p>
         </div>
 
+        {/* Camera Preview */}
+        {cameraPreviewStream && (
+          <div className="mb-4 flex justify-end">
+            <div className="relative w-32 h-24 rounded-lg overflow-hidden border-2 border-gray-300 shadow-lg">
+              <video 
+                ref={cameraPreviewRef}
+                className="w-full h-full object-cover"
+                autoPlay
+                playsInline
+                muted
+              />
+              <div className="absolute bottom-0 left-0 right-0 bg-black bg-opacity-50 text-white text-xs px-2 py-1 text-center">
+                Your Preview
+              </div>
+            </div>
+          </div>
+        )}
+
+        {/* Screen Sharing Stopped Warning */}
+        {screenSharingStopped && (
+          <div className="mb-6 p-4 bg-red-100 border-2 border-red-500 rounded-lg">
+            <div className="flex items-start gap-3">
+              <div className="text-red-600 text-2xl"></div>
+              <div className="flex-1">
+                <h3 className="font-bold text-red-900 mb-2">Screen Sharing Stopped</h3>
+                <p className="text-red-800 mb-3">
+                  Screen sharing is required to continue the interview. Please restart screen sharing to proceed.
+                </p>
+                <button
+                  onClick={restartScreenSharing}
+                  className="bg-red-600 hover:bg-red-700 text-white px-4 py-2 rounded-lg font-semibold transition"
+                >
+                  Restart Screen Sharing
+                </button>
+              </div>
+            </div>
+          </div>
+        )}
+
         {error && (
           <div className="mb-6 p-4 bg-red-50 border border-red-200 rounded-lg text-red-700">
             {error}
@@ -613,7 +1583,7 @@ export default function InterviewSession({
         <div className="flex gap-4">
           <button
             onClick={toggleRecording}
-            disabled={loading}
+            disabled={loading || screenSharingStopped}
             className={`flex-1 py-4 rounded-lg font-semibold transition shadow-lg hover:shadow-xl flex items-center justify-center gap-2 ${
               isRecording
                 ? 'bg-red-600 hover:bg-red-700 text-white animate-pulse'
@@ -635,7 +1605,7 @@ export default function InterviewSession({
 
           <button
             onClick={submitAnswer}
-            disabled={loading || !transcript.trim() || transcript === 'Recording...'}
+            disabled={loading || !transcript.trim() || transcript === 'Recording...' || screenSharingStopped}
             className="flex-1 bg-green-600 text-white py-4 rounded-lg font-semibold hover:bg-green-700 transition disabled:opacity-50 disabled:cursor-not-allowed shadow-lg hover:shadow-xl flex items-center justify-center gap-2"
           >
             {loading ? (
diff --git a/frontend/src/components/InterviewsList.tsx b/frontend/src/components/InterviewsList.tsx
index b515a32..c7f6a4f 100644
--- a/frontend/src/components/InterviewsList.tsx
+++ b/frontend/src/components/InterviewsList.tsx
@@ -1,6 +1,7 @@
 import { useEffect, useState } from 'react';
-import { Trash2 } from 'lucide-react';
+import { Trash2, UserPlus, Pencil } from 'lucide-react';
 import { getApiHeaders } from '../utils/api';
+import AddCandidateDialog from './AddCandidateDialog';
 
 interface Props { apiBaseUrl: string }
 
@@ -9,6 +10,8 @@ export default function InterviewsList({ apiBaseUrl }: Props) {
   const [error, setError] = useState('');
   const [loading, setLoading] = useState(true);
   const [deletingId, setDeletingId] = useState<string | null>(null);
+  const [showAddCandidateDialog, setShowAddCandidateDialog] = useState(false);
+  const [selectedInterviewId, setSelectedInterviewId] = useState<string | null>(null);
 
   const loadInterviews = async (abortSignal?: AbortSignal) => {
     try {
@@ -86,15 +89,38 @@ export default function InterviewsList({ apiBaseUrl }: Props) {
       <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-4">
         {items.map((it) => (
           <div key={it.id} className="rounded-lg border p-4 bg-indigo-50 cursor-pointer hover:bg-indigo-100 transition-colors relative" onClick={() => go(`/interviews/${it.id}`)}>
-            <button
-              onClick={(e) => handleDelete(it.id, e)}
-              disabled={deletingId === it.id}
-              className="absolute top-2 right-2 p-1.5 text-red-600 hover:bg-red-100 rounded transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
-              title="Delete interview"
-            >
-              <Trash2 className="w-4 h-4" />
-            </button>
-            <div className="text-lg font-semibold mb-2 pr-8">{it.name || 'Untitled'}</div>
+            <div className="absolute top-2 right-2 flex items-center gap-1">
+              <button
+                onClick={(e) => {
+                  e.stopPropagation();
+                  setSelectedInterviewId(it.id);
+                  setShowAddCandidateDialog(true);
+                }}
+                className="p-1.5 text-purple-600 hover:bg-purple-100 rounded transition-colors"
+                title="Add Candidate"
+              >
+                <UserPlus className="w-4 h-4" />
+              </button>
+              <button
+                onClick={(e) => {
+                  e.stopPropagation();
+                  go(`/create?edit=${it.id}`);
+                }}
+                className="p-1.5 text-blue-600 hover:bg-blue-100 rounded transition-colors"
+                title="Edit Interview"
+              >
+                <Pencil className="w-4 h-4" />
+              </button>
+              <button
+                onClick={(e) => handleDelete(it.id, e)}
+                disabled={deletingId === it.id}
+                className="p-1.5 text-red-600 hover:bg-red-100 rounded transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
+                title="Delete interview"
+              >
+                <Trash2 className="w-4 h-4" />
+              </button>
+            </div>
+            <div className="text-lg font-semibold mb-2 pr-16">{it.name || 'Untitled'}</div>
             <div className="flex items-center gap-2 mb-1">
               <span className={`text-xs px-2 py-1 rounded ${it.is_open !== false ? 'bg-green-100 text-green-800' : 'bg-red-100 text-red-800'}`}>
                 {it.is_open !== false ? 'Open' : 'Closed'}
@@ -102,7 +128,21 @@ export default function InterviewsList({ apiBaseUrl }: Props) {
             </div>
             <div className="text-sm text-gray-700">Mode: {it.mode}</div>
             <div className="text-sm text-gray-700">Questions: {it.question_count ?? '-'}</div>
-            <div className="text-sm text-gray-900 font-medium mt-2">Responses: {it.responses_count}</div>
+            
+            {/* Statistics */}
+            {it.stats && (
+              <div className="mt-3 space-y-1">
+                <div className="flex items-center gap-4 text-sm text-gray-700">
+                  <span className="font-medium">Sent <span className="text-gray-900">{it.stats.sent || 0}</span></span>
+                  <span className="font-medium">Given <span className="text-gray-900">{it.stats.given || 0}</span></span>
+                </div>
+                <div className="flex items-center gap-4 text-sm text-gray-700">
+                  <span className="font-medium">Shortlisted <span className="text-gray-900">{it.stats.shortlisted || 0}</span></span>
+                  <span className="font-medium">Pending <span className="text-gray-900">{it.stats.pending || 0}</span></span>
+                </div>
+              </div>
+            )}
+            
             <div className="mt-3 flex items-center gap-3">
               <button className="text-blue-700 underline text-sm hover:text-blue-900" onClick={(e)=>{e.stopPropagation(); navigator.clipboard.writeText(`${window.location.origin}/candidate/interview/${it.id}`)}}>
                 Copy candidate link
@@ -114,6 +154,20 @@ export default function InterviewsList({ apiBaseUrl }: Props) {
           <div className="text-gray-600">No interviews yet. Click Create Interview to add one.</div>
         )}
       </div>
+      
+      {showAddCandidateDialog && selectedInterviewId && (
+        <AddCandidateDialog
+          interviewId={selectedInterviewId}
+          apiBaseUrl={apiBaseUrl}
+          onClose={() => {
+            setShowAddCandidateDialog(false);
+            setSelectedInterviewId(null);
+          }}
+          onSuccess={() => {
+            // Optionally reload interviews or show success message
+          }}
+        />
+      )}
     </div>
   );
 }
diff --git a/frontend/src/utils/api.ts b/frontend/src/utils/api.ts
index b59f6ef..17bf64c 100644
--- a/frontend/src/utils/api.ts
+++ b/frontend/src/utils/api.ts
@@ -32,3 +32,127 @@ export const fetchWithAuth = async (
   });
 };
 
+export const uploadCandidateImage = async (
+  apiBaseUrl: string,
+  imageBlob: Blob,
+  responseId: string,
+  filename: string = 'candidate.png'
+): Promise<void> => {
+  const formData = new FormData();
+  formData.append('image', imageBlob, filename);
+  formData.append('response_id', responseId);
+
+  const headers = getApiHeaders(false);
+  const response = await fetch(`${apiBaseUrl}/api/media/upload-candidate-image`, {
+    method: 'POST',
+    headers,
+    body: formData,
+  });
+
+  if (!response.ok) {
+    const error = await response.json().catch(() => ({ detail: 'Failed to upload image' }));
+    throw new Error(error.detail || 'Failed to upload candidate image');
+  }
+};
+
+export const uploadScreenRecordingChunk = async (
+  apiBaseUrl: string,
+  chunkBlob: Blob,
+  responseId: string,
+  chunkIndex: number
+): Promise<void> => {
+  const formData = new FormData();
+  formData.append('chunk', chunkBlob, `chunk-${chunkIndex}.webm`);
+  formData.append('response_id', responseId);
+
+  const headers = getApiHeaders(false);
+  const response = await fetch(`${apiBaseUrl}/api/media/upload-chunk`, {
+    method: 'POST',
+    headers,
+    body: formData,
+  });
+
+  if (!response.ok) {
+    const error = await response.json().catch(() => ({ detail: 'Failed to upload chunk' }));
+    throw new Error(error.detail || 'Failed to upload recording chunk');
+  }
+};
+
+export const finalizeScreenRecording = async (
+  apiBaseUrl: string,
+  responseId: string
+): Promise<void> => {
+  // Send request to trigger video merge on backend (video file is optional now)
+  const formData = new FormData();
+  // Create a minimal dummy file - backend will merge chunks regardless
+  const dummyBlob = new Blob([''], { type: 'video/webm' });
+  formData.append('video', dummyBlob, 'final.webm');
+  formData.append('response_id', responseId);
+
+  const headers = getApiHeaders(false);
+  const response = await fetch(`${apiBaseUrl}/api/media/upload-candidate-video`, {
+    method: 'POST',
+    headers,
+    body: formData,
+  });
+
+  if (!response.ok) {
+    const error = await response.json().catch(() => ({ detail: 'Failed to finalize recording' }));
+    throw new Error(error.detail || 'Failed to finalize screen recording');
+  }
+};
+
+// Candidates API
+export const addCandidate = async (
+  apiBaseUrl: string,
+  payload: { interview_id: string; name: string; email: string; phone_number?: string | null }
+) => {
+  const res = await fetchWithAuth(`${apiBaseUrl}/api/candidates/add`, {
+    method: 'POST',
+    body: JSON.stringify(payload),
+  });
+  if (!res.ok) throw new Error((await res.json()).detail || 'Failed to add candidate');
+  return res.json();
+};
+
+export const bulkAddCandidatesCsv = async (
+  apiBaseUrl: string,
+  interviewId: string,
+  file: File
+) => {
+  const form = new FormData();
+  form.append('interview_id', interviewId);
+  form.append('file', file);
+  const headers = getApiHeaders(false);
+  const res = await fetch(`${apiBaseUrl}/api/interview/bulk-upload`, {
+    method: 'POST',
+    headers,
+    body: form,
+  });
+  if (!res.ok) throw new Error((await res.json()).detail || 'Failed to bulk import file');
+  return res.json();
+};
+
+export const listCandidates = async (
+  apiBaseUrl: string,
+  interviewId: string
+) => {
+  const res = await fetchWithAuth(`${apiBaseUrl}/api/candidates/list?interview_id=${encodeURIComponent(interviewId)}`);
+  if (!res.ok) throw new Error((await res.json()).detail || 'Failed to load candidates');
+  return res.json();
+};
+
+export const markCandidateMailSent = async (
+  apiBaseUrl: string,
+  candidateId: string,
+  mailSent: boolean
+) => {
+  const res = await fetchWithAuth(`${apiBaseUrl}/api/candidates/mark-mail-sent`, {
+    method: 'POST',
+    body: JSON.stringify({ candidate_id: candidateId, mail_sent: mailSent }),
+  });
+  if (!res.ok) throw new Error((await res.json()).detail || 'Failed to update mail status');
+  return res.json();
+};
+
+ 
\ No newline at end of file
diff --git a/frontend/vite.config.ts b/frontend/vite.config.ts
index 147380a..1fb9843 100644
--- a/frontend/vite.config.ts
+++ b/frontend/vite.config.ts
@@ -7,4 +7,8 @@ export default defineConfig({
   optimizeDeps: {
     exclude: ['lucide-react'],
   },
+  server: {
+    host: '0.0.0.0', // Allow access from network
+    port: 5173,
+  },
 });
-- 
2.51.0.windows.2

